{"pages":[{"title":"","text":"/* Name: Kimbie (dark) Author: Jan T. Sott License: Creative Commons Attribution-ShareAlike 4.0 Unported License URL: https://github.com/idleberg/Kimbie-highlight.js */ /* 新添加的內容 ------------------------------------- --hl-color 代碼框字體顔色 【必須】 (把下面.hljs的 color複製到這裏來) --hl-bg 代碼框背景色 【必須】 (把下面.hljs的 background複製到這裏來) --hltools-bg: #321a0f 代碼框頂部工具欄背景色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hltools-color: #fff 代碼框頂部工具欄字體顔色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hlnumber-bg: #221a0f 代碼框行數背景色 【可選】(如果已經關掉 line_number,可以不用配置這個) --hlnumber-color: #fff 代碼框行數字體顔色 【可選】 (如果已經關掉 line_number,可以不用配置這個) --hlscrollbar-bg: #d3af86 代碼框滾動條顔色 【可選】（默認為主題主顔色） --hlexpand-bg: #d3af86 代碼框底部展開背景色 【可選】(如果已經關掉 highlight_height_limit,可以不用配置這個) */ :root { --hl-color: #d3af86; --hl-bg: #221a0f; --hltools-bg: #321a0f; --hltools-color: #fff; --hlnumber-bg: #221a0f; --hlnumber-color: #fff; --hlscrollbar-bg: #d3af86; --hlexpand-bg: #d3af86; } /* Kimbie Comment */ .hljs-comment, .hljs-quote { color: #d6baad; } /* Kimbie Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-meta { color: #dc3958; } /* Kimbie Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-deletion, .hljs-link { color: #f79a32; } /* Kimbie Yellow */ .hljs-title, .hljs-section, .hljs-attribute { color: #f06431; } /* Kimbie Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #889b4a; } /* Kimbie Purple */ .hljs-keyword, .hljs-selector-tag, .hljs-function { color: #98676a; } /* 更改的內容 把.hljs改為 #article-container figure.highlight .hljs *、 /* ------------------------------------- */ #article-container figure.highlight .hljs { display: block; overflow-x: auto; background: #221a0f; color: #d3af86; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }","link":"/self/Kimbiedark.css"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android屏幕适配知识总结","text":"1. 概念解释屏幕尺寸手机对角线的物理尺寸，单位：英寸（inch），1英寸=2.54cm 屏幕分辨率手机在横向、纵向上的像素点数的总和，由横向像素数 * 纵向像素数表示（1280*720），每个像素都是1px 屏幕PPI（屏幕像素密度）表示每英寸像素数，则在相同尺寸下，PPI越高，则越清晰。在PPI相同的情况下，屏幕尺寸越大，越模糊。 eg：小米8的像素密度为402PPI DPI是印刷业使用的单位，其表示的是打印纸上每一英寸包含的墨点数量，网络上的观点是Google误用了该单位。在android中可以将PPI与DPI等价看待。 物理上DPI值是一个固定值，无法修改。但Android系统中的densityDpi参数可以通过root或adb命令修改。修改后会有一个Physical density 与Override density。 Density DisplayMetrics.density 该density是为了方便px与dp的转换，额外提供了此参数，density = densityDpi / 160。 adb shell wm density 这个density其实就是dpi的概念。 很多文章中的density也就是指的是dpi。 DP密度无关像素(density-independent pixel)，与终端上的实际物理像素点无关。 在dpi = 160的设备上，1dp=1px。当dpi提升到240时，1dp所能表示的像素点提高，扩大到(240/160)=1.5倍，此时1dp=1.5dp。 dp与px转换可以使用 px = dp * (densityDpi / 160)或者px = dp * density。 SP可缩放像素，与dp基本相同，用于字体大小设置。唯一不同就是sp会随着系统设置的字体缩放进行缩放。 2.适配方案为什么不使用Android的dp适配方案 屏幕分辨率为：1920*1080，屏幕尺寸为5吋的话，那么dpi为440。假设我们UI设计图是按屏幕宽度为360dp来设计的，那这样会存在什么问题呢？在上述设备上，屏幕宽度其实为1080/(440/160)=392.7dp，也就是屏幕是比设计图要宽的。这种情况下， 即使使用dp即使写了最大的dp值，也无法填充满屏幕。 同时还存在部分设备屏幕宽度不足360dp，这时就会导致按360dp宽度来开发实际显示不全的情况。 会导致按设计图换算过来的最大尺寸小于设备实际最大尺寸 使用RelativeLayout、ConstraintLayout进行百分比布局如果只考虑控件大小与位置情况，使用此方案可以解决大部分问题，但对于涉及到TextView等文字大小显示问题，依旧存在上述dp方案所存在的缺陷问题。（相同sp实际在不同手机中显示的大小不一致） 尺寸（size）限定符适配将设计图的尺寸作为基准，比如设计图为360x640，手机实际的分辨率根据这个基准宽高生成对应的尺寸文件。 例如一款720x1280的手机： 宽为720，将宽度分为360份，取值为x1到x360，则取值如下 123&lt;dimen name=&quot;x1&quot;&gt;2.0px&lt;/dimen&gt;&lt;dimen name=&quot;x2&quot;&gt;4.0px&lt;/dimen&gt;... 高也同理，生成相应的y1,y2…y640的数值。 将生成的dimens文件放到values-720x1280中，开发中使用R.dimens.x120，R.dimens.y60进行布局开发。 如果手机实际尺寸没有找到对应的尺寸限定符，就会去默认的dimens中取尺寸 缺点： 需要生成大量的dimes文件。该方案为了适配及其小众的尺寸手机，会占用大量存储空间，导致增加安装包的大小。即使生成了大量的文件，也不可能覆盖不到全部的机型。 手机实际尺寸比例可能与设计稿不同，导致UI拉伸。设计图可能是16:9，而手机可能是16:10等其他尺寸。 最小宽度（Smallest-width）限定符同尺寸限定符适配同理，通过生成大量的dimen文件期望覆盖大量机型尺寸。与尺寸限定符不同的是，尺寸限定符在没有匹配到相应的限定符时，会直接去默认的dimen中寻找尺寸，而sw限定符如果没有找到与自己相同的文件夹，会找小一点的最近dimens，这样，只要dimens文件夹生成的间隔控制的得当，UI也不会有很大的偏差，也不需要占用大量的安装包空间。 系统会将屏幕较小的那一边的尺寸计算为dp，计算后的值就去匹配对应限定符。 比如分辨率为1280x720，densityDpi为240dpi的设备。短边为720px，此设备的denstiy=240/160=1.5，那么最小宽度即为720/1.5=480dp (px = dp * density)，这样这个设备会从value-sw480dp的文件夹下取资源。 而每个限定符文件夹中的dimens的生成规则和尺寸限定符相同，按照设计图的尺寸与最小宽度dp进行比例计算 假如设计图的分辨率为1920x1080，设备计算出的最小宽度为sw440dp，那么设计图中的1px = 440dp/1080 = 0.407dp，依据此规则依次生成其他尺寸的px所对应的dp值即可。 选用最小宽度进行适配还有一个好处是布局过程中UI的宽高都使用一个边生成的尺寸进行开发，不像尺寸适配符宽取x的值，高取y的值，使用两个边的尺寸开发，当出现屏幕尺寸比例与设计图比例不相同的时候，不会被拉伸。 更多的限定符见限定符表 头条适配方案Android原生dp方案最大的缺点是每个View的dp是写死不变的，但是手机最大的dp值随着尺寸的变化而变化。而头条方案保证了设计图中标注的最大dp值转换出的px值为都为手机的最大尺寸。 头条方案通过计算屏幕尺寸与设计图的比例，计算出targetDensity = screenWidth / uiWidth; 动态修改DisplayMetrics#density ,DisplayMetrics#densityDpi,参数，使得系统在将xml中的dp值转换为px时，px = dp * targetDensity，保证了在各个屏幕尺寸的一致性。 在转换sp时，DisplayMetrics#scaledDensity(字体的缩放因子)需要对系统字体缩放进行进一步处理 1targetScaledDensity = targetDensity * (scaledDensity / density) 并需要在Application#registerComponentCallbacks 注册下 onConfigurationChanged监听字体缩放变化，实时更改最新的targetScaledDensity。 一种极低成本的Android屏幕适配方式 骚年你的屏幕适配方式该升级了!-今日头条适配方案 AndroidAutoSize 其他尺寸问题getDimension、getDimensionPixelOffset 和 getDimensionPixelSize区别 相同点：返回获取某个dimen的值，如果dimen单位是dp或sp，则需要将其乘以density（屏幕密度）；如果单位是px，则不用。 不同点：getDimension：返回类型为float，getDimensionPixelSize：返回类型为int，由浮点型转成整型时，采用四舍五入原则。getDimensionPixelOffset：返回类型为int，由浮点型转成整型时，原则是忽略小数点部分。 TextView中的setTextSize参数问题TextView.java1public void setTextSize(int unit, float size) 其实很好理解，参数unit就是代表传入的size的类型，如果unit为TypedValue.COMPLEX_UNIT_SP,那么就会将传入的size按sp的方式计算（乘density），最终转化为px值。如果直接传入TypedValue.COMPLEX_UNIT_PX，就不需要转换为px值。 一个小例子： example.java1textView.setTextSize(TypedValue.COMPLEX_UNIT_SP,getResources().getDimension(R.dimen.fontsize)) app/src/main/res/values/dimens.xml1&lt;dimen name=&quot;font1&quot;&gt;18sp&lt;/dimen&gt; 这种情况时，getResources().getDimension()在获取值的时候已经将18*density转换为px值后，然后再TextView中设置时又再次*density，相当于TextView最终设置到的字体大小为18*density*density。 附录：常见密度限定符对应表 密度限定符 说明 ldpi 适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源。 mdpi 适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度）。 hdpi 适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源。 xhdpi 适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源。 xxhdpi 适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源。 xxxhdpi 适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源。 nodpi 适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源。 tvdpi 适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px。","link":"/2022/06/15/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"title":"Android的TouchMode","text":"什么是TouchModeTouchMode就是”触摸模式“。在一般情况下，Android系统都是处于TouchMode的模式下也就是View.isInTouchMode() == true的状态下。大多Android开发都是开发的手机App应用，所以可能没有接触或使用过TouchMode，而在开发Android TV应用或其他没有触摸屏的应用时会接触到这个TouchMode，但一旦使用遥控器遥控或调用了View.requestFocusFromTouch等可以更改TouchMode的方法后，系统就会退出TouchMode，当用户点击屏幕后，就会进入触屏模式也就是TouchMode模式。 TouchMode的影响是否处于TouchMode会对控件的焦点（focus）产生影响。 当处于TouchMode时，直接请求requestFocus()是无效的，因为requestFocus()会最终调用到View.requestFocusNoSearch() 123456789101112131415 private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) { ... // need to be focusable in touch mode if in touch mode if (isInTouchMode() &amp;&amp; (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) { return false; } ... return true;} 而其内部进行判断了isInTouchMode(),当处于触摸模式下，会直接返回false，导致请求焦点失败。 在这个模式下，大多是View是无法获取到焦点的，如果你在开发TV应用时，发现每当开机后，焦点不能准确的选中设定的那一个，那么就需要检查下你的TouchMode与是否使用了requestFocus()进行请求焦点。 像一些EditView等一些特殊的View，是可以下TouchMode下获取到焦点的，因为这些View的isFocusableInTouchMode()为true，其他的View被点击时不会获得焦点，只是会触发onClick() 如何更改TouchMode 退出TouchMode 直接调用View.requestFocusFromTouch() 12345678910111213141516171819202122232425262728293031// View.requestFocusFromTouch public final boolean requestFocusFromTouch() { // Leave touch mode if we need to if (isInTouchMode()) { ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null) { // 此处就是将TouchMode设置为false viewRoot.ensureTouchMode(false); } } return requestFocus(View.FOCUS_DOWN); } // ViewRootImpl.ensureTouchMode boolean ensureTouchMode(boolean inTouchMode) { if (DBG) Log.d(&quot;touchmode&quot;, &quot;ensureTouchMode(&quot; + inTouchMode + &quot;), current &quot; + &quot;touch mode is &quot; + mAttachInfo.mInTouchMode); if (mAttachInfo.mInTouchMode == inTouchMode) return false; // tell the window manager try { // 此处真正设置TouchMode，而mWindowSession是一个全局的单例对象， // 故设置后TouchMode是可以整个应用内生效的 mWindowSession.setInTouchMode(inTouchMode); } catch (RemoteException e) { throw new RuntimeException(e); } // handle the change return ensureTouchModeLocally(inTouchMode); } 进入TouchMode 随意点击或滑动即可进入TouchMode模式 123456// Enter touch mode on down or scroll, if it is coming from a touch screen device,// exit otherwise.final int action = event.getAction();if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_SCROLL) { ensureTouchMode(event.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));}","link":"/2021/03/30/Android%E7%9A%84TouchMode/"},{"title":"《Android开发艺术探索》笔记","text":"第一章 Activty的生命周期和启动模式Activity的生命周期全面分析典型情况下的生命周期分析在正常的情况下，Activity会经历如下生命周期。 onCreate: 表示Activity正在被创建,是生命周期的第一个方法 onRestart: 表示Activity正在被重新启动。一般由用户从ActivityA启动ActivityB后，重新返回ActivityA触发。 onStart: 表示Activity已经可见，但无法与用户交互。（没有获取到焦点） onResume: 表示activity获得了焦点，用户可以进行操作。 onPause: Activity正在停止，失去了焦点，不能进行操作。此时可以做一些存储数据、停止动画等工作，但不能太耗时，会影响新Activity的显示 （新Activity的onResume会在老Activity的onPause方法后执行） onStop: 表示Activity即将停止，对用户来说已经不可见。 可以在此时做稍重的回收工作，也不能太耗时。一般的操作尽量在onStop中执行,不要放到onPause中 onDestory : 表示activity即将被销毁,是最后一个回调。可以做回收工作和最终资源的释放。 异常情况下的生命周期分析 资源相关的系统配置发生改变导致Activity被杀死并重新创建 在不对Activity进行配置时，旋转手机等操作会使系统配置发生改变，会引发Activity销毁并重新创建。 销毁 当Activity开始销毁时，其onPause、onStop、onDestory均会被调用，并在onStop之前调用onSaveInstanceState来保存当前Activity的状态 （与onPause没有明确的调用前后顺序）。 保存 将需要保存的数据保存到onSaveInstanceState传入的bundle中。注意：onSaveInstanceState有俩个同名函数，通常只需重写onSaveInstanceState(Bundle outState)的即可，onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) {只有在activity中配置persistableMode标签才会调用，此标签用于数据的持久化。 恢复 当Activity重建后，会将保存的bundle数据在onCreate(Bundle b)的参数中传入,并调用onRestoreInstanceState。如果要在onCreate中进行状态恢复需要进行对bundle进行判空，推荐在onRestoreInstanceState中进行状态的恢复,因为该方法一旦调用，其参数一定不为空。 onRestoreInstanceState的调用时机在onStart之后，与onResume的调用时机不能保证。 调用输出顺序 12345678910111213141516//Activity正常创建I/Main2Activity: onCreate: I/Main2Activity: onStart: I/Main2Activity: onResume: //屏幕旋转导致Activity开始销毁I/Main2Activity: onPause: //保存数据I/Main2Activity: onSaveInstanceState:I/Main2Activity: onStop: I/Main2Activity: onDestroy: //开始重建I/Main2Activity: onCreate: I/Main2Activity: onStart: //恢复数据I/Main2Activity: onRestoreInstanceState:I/Main2Activity: onResume: 系统只有在Activity即将被销毁并有机会重新显示的情况下才会调用`onSaveInstanceState`,正常退出的Activity是不会触发调用 资源内存不足导致低优先级的Activity被杀死 Activity优先级排序 前台Activity – 正在和用户交互的Activity,优先级最高 可见但非前台Activity – 比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法与用户直接交互。 后台Activity – 已经被暂停的Activity，比如执行了onStop,优先级最低。 当系统系统内存不足时，系统会按照上述优先级去杀死Activity所在的进程，并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数据。 Activity的启动模式Activity的LaunchMode standard: 标准模式，也是默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中。 当用ApplicationContext去启动standard模式的Activity会报错，因为非Activity类型的Context没有任务栈，此时，需要为Activity指定FLAG_ACTIVITY_NEW_TASK标记位新建一个任务栈来存放这个Activity。此时，该Activity实际上使用singTask模式启动的 singleTop: 栈顶复用模式。如果新Acitivy已经位于任务栈的栈顶，那么此Activiy不会被重新创建，但是会被调用该Activity的onNewIntent方法。 singleTask: 栈内复用模式，在这种模式下，入栈时，在目标栈中如果存在此Activity实例，那么不会重新创建实例。当已经存在的实例不在栈顶时，会先将栈中实例之上的Activity全部出栈，移出任务栈，使singleTask模式的Activity位于栈顶。当栈中存在的实例在栈顶时，直接入栈，并调用onNewIntent 单实例模式。该模式具有singleTask模式的所有特性外，还有这个模式的Acitivity只能单独的位于一个任务栈中。启动时，会新建一个任务栈，该任务栈只会有该Acitivity一个实例。 任务栈回退在存在多个任务栈的情况下，由前台任务栈（第一个有焦点的Activity所在的任务栈）启动后台任务栈中的Activity的时候，整个后台任务栈会被切换为前台任务栈，整个栈中的Activity都会前移，之前的前台任务栈集体后移。 当启动ActivityD时的任务栈 当启动ActivityC时的任务栈 ActivityD被出栈的原因：++当启动ActivityC时，C处于后台任务栈中，首先将整个任务栈提到前台任务栈，变为 D -&gt; C -&gt; B -&gt; A,又因为C的启动模式为SingleTask，当不为栈顶时会将之上的Activity全部出栈。++ onNewIntent的调用时机Activity 的 Flags第三章 View的事件体系View基础知识View的位置参数View的位置信息由4个顶点来决定，分别为top、left、bottom、right，这都是相对于View的父控件来说的。所以 12width = right - leftheight = bottom - top 从Android3.0开始增加了x,y,translationX,translationY。其中x，y是View左上角的坐标，translationX和translationY是View左上角相对于父容器的偏移量。换算关系如下 12x = left + translationXy = top + translationY View在平移变换中，top，left表示的是原始左上角的位置信息 ，不会改变，而x，y，translationX，translationY会发生改变 MotionEvent 和 TouchSlop MotionEvent 通过MotionEvent可以获得点击事件的x，y坐标。getX/getY获取的是相对于当前View左上角的x和y，而getRawX/getRawY获取的是相对于手机屏幕左上角的坐标 TouchSlop TouchSlop为滑动的最小距离，当小于这个距离则不认为是滑动，TouchSlop是一个常量，和设备有关，在不同的设备上有可能不同，可以通过ViewConfiguration,get(getContext()).getScaledTouchSlop()。当处理滑动时，可以获取这个值进行判断来认为是不是滑动。 VelocityTracker GestureDetector 和 Scroller VelocityTracker VelocityTracker用于计算滑动速度。在View的onTouchEvent中进行创建和添加监听 12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 初始化完成就可以获取水平方向和垂直方向的滑动速度。在获取速度之前，必须要先调用computeCurrentVelocity进行计算速度。 1234//必须先调用这个velocityTracker.computeCurrentVelocity(1000); //设置时间间隔为1000，计算在这个时间间隔中运动了多少个像素 Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity()); Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getYVelocity()); 使用完成后，需要进行释放 123velocityTracker.clear();velocityTracker.recycle();velocityTracker = null; GestureDetector 手势检测工具，用于辅助检测用户的单击、滑动、长按、双击 回调接口： OnGestureListener，这个Listener监听一些手势，如单击、滑动、长按等操作； 方法名 描述 onDown 手指轻轻触摸屏幕的一瞬间，由1个Action_down触发 onShowPress 手指轻轻触摸屏幕，尚未松开或拖动，由1个ACTION_DOWN触发 onLongPress 用户长按屏幕 onSingleTapUp 用户手指松开（UP事件）的时候如果没有执行onScroll()和onLongPress()这两个回调的话，就会回调这个，说明这是一个点击抬起事件，但是不能区分是否双击事件的抬起。 onScroll 手指按下并拖动，由1个ACTION_DOWN+多个ACTION_MOVE触发 onFling 用户执行快速滑动之后的回调，MOVE事件之后手松开（UP事件）那一瞬间的x或者y方向速度，如果达到一定数值（源码默认是每秒50px），就是快速滑动操作（也就是快速滑动的时候松手会有这个回调，因此基本上有onFling必然有onScroll）。 OnDoubleTapListener，这个Listener监听双击和单击事件。 方法名 | 描述 ---|--- onSingleTapConfirmed | 可以确认（通过单击DOWN后300ms没有下一个DOWN事件确认）这不是一个双击事件，而是一个单击事件的时候会回调。 onDoubleTap | 可以确认这是一个双击事件的时候回调。 onDoubleTapEvent | onDoubleTap()回调之后的输入事件（DOWN、MOVE、UP）都会回调这个方法（这个方法可以实现一些双击后的控制，如让View双击后变得可拖动等）。 OnContextClickListener 平板接入外接键盘后，鼠标/触摸板，右键点击时候的回调。 SimpleOnGestureListener，实现了上面三个接口的类，拥有上面三个的所有回调方法。一般会使用该接口 使用方式： 123456789101112131415//创建GestureDetector对象private void init(Context context) { mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener(){ @Override //按需重写相关回调 public boolean onDown(MotionEvent e) { return super.onDown(e); } });}//接管View的onTouchEvent@Overridepublic boolean onTouchEvent(MotionEvent event) { return mGestureDetector.onTouchEvent(event);} 3.Scroller 使用Scroller对象完成弹性滑动 12345678910111213141516Scroller mScroller = new Scroller(mContext);//缓慢移动到指定位置private void smoothScrollTo(int destX,int destY){ int scrollX = getScrollX(); int delta = destX - scrollX; //1000ms内滑向destX,效果就是慢慢滑动 mScroller.startScroll(scrollX,0,delta,0,1000); invalidate();} @Overridepublic void computeScroll(){ if(mScroller.computeScrollOffset()){ scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); }} View的滑动使用scrollTo/scrollBy完成View的滑动Android源码 12345678910111213141516171819202122232425262728293031/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } }}/** * Move the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y);}","link":"/2021/03/26/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0/"},{"title":"精妙的位运算","text":"位运算 与运算（and） &amp;表示，当两个相同位对应的数都是 1 的时候，该位获得的结果才是 1，否则为 0例如说6 &amp; 11，转换为二进制就是0110 &amp; 1011，结果为0010。在位运算中常常与mask进行提取对应位值的操作。 或运算（or） |表示，当两个相同位对应的数只要有一个数 1 的时候，该位获得的结果为 1，否则为 0还是用 6 和 11 这两个数做例子，就是0110 | 1011 = 1111。在位运算中可以起到赋值的作用。 非运算（not） ~表示将每一位按位取反（原来是 0 结果就是 1，原来是 1 结果就是 0）。~110 = 001在对Int值进行非运算时，因为计算机中存储的是补码，此时的非运算对补码进行取反后，再还原为原码后就会变为奇怪的值。 为何~1等于-2，~0等于-1呢 异或运算（xor） ^表示，当两个相同位对应的数字不同的时候为 1，否则为 0，可以用A ^ B == 0来判断两个数是否相等。例如说：0110 ^ 1011 = 1101。可以用于判断两值是否相同并且提取出改变的位 左移（shl） &lt;&lt;表示，a &lt;&lt; b表示 a 左移 b 位，由于移位在末位多出来的未知数字补零。在这里面可以等价为a * 2^b这个运算（针对十进制）。0001 &lt;&lt; 1 = 0010 相当于1 * 2^1 = 2 右移（shr） &gt;&gt;表示，a &gt;&gt; b表示将 a 右移 b 位，原本的末位进行右移后会被舍弃，左边的用原有标志位补充，正数补0，负数补1。同样的，右移在十进制里面也可以近似为a / (2^b)的形式，不过要对结果取整，也不一定准确，只能够说意思大概如此。 无符号右移 &gt;&gt;&gt;表示，不管正负标志位为 0 还是 1，将该数的二进制码整体右移，左边部分总是以 0 填充，右边部分舍弃。 运算优先级： ~ &gt; &lt;&lt; = &gt;&gt;= &gt;&gt;&gt; &gt; &amp; &gt; ^ &gt; | &gt; &amp;&amp; &gt; || Android源码中的应用View在View.java的源码中，各种View状态都是保存到类型为Int的mViewFlags字段中，每一位或多位代表一个属性的状态，例如static final int ENABLED_MASK = 0x00000020;代表了从二进制的右侧数第6位的值代表了当前是否为ENABLED状态。 mViewFlags共使用了32位来存储状态，源码中表示为0x00000000，每一个0都是4位。而0x00000010中1为使用该4位中的最后一位，相同的，2为第三位，4为第二位，8为第一位。 修改mViewFlags的值在setFlags(flag,mask)方法中： View.java123456789101112void setFlags(int flags, int mask) { // ... int old = mViewFlags; // 设置新的flag值 mViewFlags = (mViewFlags &amp; ~mask) | (flags &amp; mask); // 判断是否值没有改变 int changed = mViewFlags ^ old; if (changed == 0) { return; } // ...} 其中，(mViewFlags &amp; ~mask)是将mask所标志的所在位原有值去除，(flags &amp; mask)提取出要赋值的新值，并通过或运算|赋值至mViewFlags。此时新旧两值通过异或^判断值是否发生了改变。如果不相等，当前changed中为1的位为本次修改的位。 举个例子：假设当前mViewFlags = 0x00400010，此时，我们想要将当前View设置为disable状态，调用了setFlags(DISABLED,ENABLED_MASK)，int DISABLED = 0x00000020,int ENABLED_MASK = 0x00000020，那么，当前的(mViewFlags &amp; ~mask) = 0x00400010 &amp; ~0x00000020 = 0x00400010 &amp; 0xffffffdf = 0x00400010，而(flags &amp; mask) = 0x00000020 &amp; 0x00000020 = 0x00000020，最终mViewFlags = 0x00400010 | 0x00000020 = 0x00400030，最后changed计算出mViewFlags ^ old为0x00000020，也就是等于mask的值。 在setFlags的剩余代码中，可以看到其他的位运算 View.java setFlags()12345678if (((changed &amp; FOCUSABLE) != 0){ // 等于0则说明对应位没有发生变化，不等于0则说明发生了变化 //...}if (((old &amp; FOCUSABLE) == FOCUSABLE) {// FOCUSABLE此时相当于一个mask，取出对应位进行值比较 //...}mPrivateFlags |= PFLAG_DRAWN; // 赋值新的属性值 位掩码BitMask的作用mask标记了某一组属性所使用的一个或多个位，在获取对应属性状态时可以对mask进行&amp;运算获得对应的值，屏蔽其他位的影响。保证了一定的安全性、可靠性。 MeasureSpecMeasureSpec是一个32位的int值，高2位为SpecMode，低30位为SpecSize View.MeasureSpec.java123456789101112131415161718192021222324252627282930public static class MeasureSpec { private static final int MODE_SHIFT = 30; // SpecMode的位掩码 0x30000000 private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int getMode(int measureSpec) { // 与位掩码and运算得出SpecMode return (measureSpec &amp; MODE_MASK); } public static int getSize(int measureSpec) { // 去除SpecMode所在位，剩下位即是Size return (measureSpec &amp; ~MODE_MASK); } public static int makeMeasureSpec(int size,int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { // 与View的flag赋值一样，先清除之前设置的值，后进行and运算赋值 return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); } }} 位运算的优缺点优点 省去了创建过多的属性变量，将多个属性集中到一个Int中进行管理 运算效率高，并且可以同时进行多个属性的赋值、修改操作。例如setFlags(A|B,A_MASK|B_MASK) 缺点不经常使用的话看起来太费劲，并不直观。 参考文献弄懂 Android 源码中那些巧妙位运算 谈谈位运算和在Android中的运用","link":"/2022/06/22/%E7%B2%BE%E5%A6%99%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"设置屏幕缩放后缩放距离变为双倍","text":"复现步骤（问题） 在Android6.0系统中设置屏幕缩放，向内缩小屏幕任意范围 在一定的条件下，如关闭一个dialog风格的activity、关闭popupwindow 会发现向内缩小的屏幕尺寸变大一倍 解决通过Android Studio中的layout inspector分析发现：屏幕缩放的实现方式是在DecorView中设置padding进行屏幕变化，但出现问题后，一个id为action_bar_root的FitWindowsLinearLayout中也出现了相同数值的padding。找到相应的abc_screen_simple.xml后发现这个View上配置了android:fitsSystemWindows=&quot;true&quot; 大部分的时候，你的应用都不会在状态栏和导航栏下面显示内容，如果你需要在他们下面显示内容，则需要确保你应用的可交互控件（比如按钮）不要显示在系统窗口下面了。 android:fitsSystemWindows=“true” 默认行为就是通过在 View 上设置和系统窗口一样高度的边框（padding ）来确保你的内容不会出现到系统窗口下面。 https://blog.chengyunfeng.com/?p=905 所以将这个fitsSystemWindows值改为false即可。 12345678override fun onResume() { super.onResume() handler.post { // 更改为false window.decorView.findViewById&lt;View&gt;(R.id.action_bar_root).fitsSystemWindows = false } }","link":"/2021/05/07/%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE%E5%90%8E%E7%BC%A9%E6%94%BE%E8%B7%9D%E7%A6%BB%E5%8F%98%E4%B8%BA%E5%8F%8C%E5%80%8D/"},{"title":"JavaWeb笔记","text":"JDBC基本使用123456789101112131415//注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//获取数据库连接对象Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://59.110.213.97:3306/test?useSSL=false&quot;, &quot;root&quot;, &quot;GHn,.155070&quot;);//定义sql语句String sql = &quot; insert into table_test(id,number) values(null,10086)&quot;;//获取执行sql的对象Statement statement = connection.createStatement();//执行sqlint count = statement.executeUpdate(sql);System.out.println(count);//释放资源statement.close();connection.close(); 常用类介绍DriverManager驱动管理对象 注册驱动 在Class.forName(&quot;com.mysql.jdbc.Driver&quot;);中有个静态代码块，使用了DriverManager进行注册驱动 1234567static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(&quot;Can't register driver!&quot;); }} 在mysql5之后 可以不写class.forname进行加载，会自动进行加载 获取数据库连接 static Connection getConnection(String url,String user, String password) url : jdbc:mysql://ip地址:端口/数据库名称 如果为本机数据库，而且端口为3306，可以简写为jdbc:mysql:///数据库名称 Connection数据库连接对象 获取执行sql的对象(Statement/PreparedStatement) Statement createStatement() PreparedStatement preparedStatement(String sql) 管理事务 开始事务：setAutiCommit(boolean autoCommit) 提交事务: commit() 回滚事务：rollback() Statement静态sql(不设置站位数据)执行对象 boolean execute(String sql) 可以执行任意sql int executeUpdate(String sql) 可以执行 增删改 和 创建修改删除 sql语句，返回受影响的行数 ResultSet executeQuery(String sql) 执行查询sql ResultSet查询的结果 boolean next() 游标向下移动一行,返回是否还有数据 getXXX() XXX : Int、String等 参数: 1. int 列的编号，从1开始，getInt(1)为获取第一列的int类型的值 2. String 列的名称 PreparedStatement预编译sql执行者 sql编写: select * from table where name = ?; 创建PreparedStatement Connection.preparedStatement(sql) 给占位符设置值 setXXX(参数1:编号从1开始，参数2：要设置的值) 执行sql executeUpdate()/executeQuery() 数据库连接池存放数据库连接的容器 当系统被创建，容器被创建，容器中会申请 一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。 好处 ： 节约资源 用户访问高效 实现使用javax.sql下的DataSource接口 方法 获取连接：getConnection() 归还连接：Connection.close() 。 此处调用的close不会关闭连接，而是归还连接。 C3P0实现 导入jar包 2个 c3p0-0.9.5.2.jar、mchange-commons-java-0.2.11.jar 定义配置文件 名称：c3p0-config.xml 、c3p0.properties 放到src文件夹下即可 创建数据库连接对象 123DataSource dataSource = new ComboPooledDataSource();//或DataSource dataSource = new ComboPooledDataSource(&quot;congifName&quot;); 获取连接 Connection connection = dataSource.getConnection(); Druid 导入jar包 druid-1.0.9 定义配置文件 properties格式，可起任意名放到任意目录 加载配置文件 1234//加载配置文件Properties properties = new Properties();InputStream resourceAsStream = Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);properties.load(resourceAsStream); 创建数据库连接对象 123//获取连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);dataSource.getConnection(); 获取连接 Connection connection = dataSource.getConnection(); Spring JDBC(JDBCTemplate)用于简化JDBC操作,自动归还连接至连接池中 创建JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(); 增删改 int update = jdbcTemplate.update(sql,value1...); 查询并将结果封装为Map 只能查询结果为1的数据 Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(sql); 查询并将结果封装为List List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(sql); 查询并将结果封装为JavaBean 1234567List&lt;JavaBean&gt; query = jdbcTemplate.query(sql, new RowMapper&lt;JavaBean&gt;() { @Override public JavaBean mapRow(ResultSet resultSet, int i) throws SQLException { //组装对象 return null; }}); 12//使用提供的实现类实现自动封装List&lt;JavaBean&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;JavaBean&gt;(JavaBean.class)); 指定查询结果的数据类型 一般用于聚合函数 1Long aLong = jdbcTemplate.queryForObject(sql, Long.class); JavaScriptECMAScript包含一些基本的对象，基础的语法，是所有客户端脚本语言的标准 特殊语法 语句以;结尾如果一行只有一条语句可以不写; 变量的定义使用var，也可以不使用 用var：变量为局部变量 不用var：变量为全局变量 与html的结合方式 内部JS 可以写到html的任意位置，但越靠上越先执行 外部JS 1&lt;script src=&quot;路径&quot;&gt;&lt;/script&gt; js文件 12//不需要&lt;script&gt;标签js代码 数据类型 原始数据类型 number 数字。 整数、小数、NaN(不是数字,与任何值进行==运算皆为false，包括自己) string 字符串(没有字符的概念) “abv”,’ac’,’a’ boolean null undefined：未定义。如果一个变量没有初始化值，则会被默认赋值为undefined null使用typeof运算符会得出为object类型 引用数据类型：对象 类型转换其他类型转number string转number类型 如果字面值为数字则按字面值进行转换，如果不是为字母，则转为NaN boolean转number类型 true为1 false为0 其他类型转boolean string转boolean类型 除了空字符串(“”)，其他都为true number转boolean 0或NaN为false，其他为true null和undefined 都为false 对象 都为true 运算符 一元运算符(+ -) 如果在运算数前加正负号，会自动将运算数转为数字类型。 等于与全等于 ==等于 类型不同时先进行转换，再比较 === 全等于 不会转换类型，类型不相同就为false 基本对象Function函数对象 创建 1. 1var fun = new Function(&quot;a&quot;,&quot;b&quot;,&quot;alert(a+b);&quot;); 2. 123function fun(a,b) { alert(a+b);} 3. 123var fun = function(a,b) { alert(a+b);} 属性 length 参数的个数 特点 有返回值的时候直接return就可以 可以在方法中传入与规定的参数不同数量的 参数（可多可少 ），少了的参数为undefined 隐藏对象：为一个数组arguments,存放了所有的传入的参数。 Array数组 创建 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 方法 join(分割符):将数组中的元素按照指定的分隔符拼接为字符串。如不传如分割符则默认为, push(元素): ；在末尾添加元素。类似于java中List.add(); 特点 JS中元素的类型是可变的，可以存放任意类型的数据 长度可变，当访问超出大小的下标的数据时，自动扩容。 Boolean布尔类型的包装类 Date日期对象 创建 var date = new date(); 方法 toLocalString(): 返回当前date对象对应的时间本地字符串格式 getTime(): 获取毫秒值，返回现在时间到1970年1月1日的毫秒值差 Math1.特点 不需要创建 方法 Math.random()： 返回[0,1)的随机数。 Math.round(x)： 把数四舍五入为最接近的整数。 RegExp正则表达式对象 创建 var reg = new RegExp(&quot;正则表达式&quot;); var reg = /正则表达式/; 方法 boolean flag = reg.text(&quot;str&quot;): 测试当前字符串是否符合正则表达式 Global 特点 全局对象，这个global对象封装的方法不需要对象就可以直接调用。 方法 encodeURI()、dncodeURI(): url编解码 encodeURIComponent()、dncodeURIComponent(): url编解码,编码的字符更多，会将encodeURI不会编码的/等字符进行编码。 parseInt() 将字符串逐一判断是否为数字，将第一个字符前的数字转为number isNaN() 判断是否等于NaN evel(str) 将一个字符串作为js代码进行执行 BOMBrowser Object Model 浏览器对象模型 Window窗口对象,可以获取其他BOM对象 特点 不需要创建，可以直接使用window.方法名()进行调用. window也可以省略。方法名() 方法 与弹出框有关的方法 alert(&quot;str&quot;) 显示一个带有一段消息和一个确认按钮的警告框 confim(&quot;str&quot;) 显示一个带有一段消息以及确认按钮和取消按钮的对话框。返回为true为点击确定，返回false为点击取消 prompt(&quot;str&quot;): 显示可提示用户输入的对话框,返回值为用户输入的信息。 与打开关闭有关的方法 open(&quot;url&quot;)、window.close() 打开一个新窗口、关闭该window对象的窗口。**open会返回一个window对象，可通过该对象对新窗口进行操作，例如关闭窗口.** 与定时器有关的方法 setTimeout(fun(),timeout)、clearTimeout() 一次性的定时器 1234vat timeout = 3000;var id = setTimeout(fun(),timeout);//通过id取消定时器clearTimeout(id); setInterval(fun(),timeout)、clearInterval() 周期性的定时器 1234vat timeout = 3000;var id = setInterval(fun(),timeout);//通过id取消定时器clearInterval(id); 属性 获取其他BOM对象 history navigator location screen 获取DOM对象 document History历史记录对象:包含了用户在当前窗口中访问过的url 获取 window.history 方法 back() : 访问历史列表中前一个 url forward() : 访问历史列表中下一个 url go() : 访问历史列表某个具体的 url 属性 lenght : 当前窗口历史列表中url数量 Location地址栏对象 获取 window.location 方法 reload() : 刷新 属性 href : 当前完整的url路径 Navigator浏览器对象 可以获取浏览器的名称、版本等信息 Screen显示屏对象 可以获取显示屏的宽高等信息 DOMDocument Object Model 文档对象模型 将标记语言文档的各个组成部分，封装成对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作。 核心DOM模型对象针对任何结构化文档的标准模型 Document ：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，其他5个的父对象 Document 方法 获取Element对象： getElementById() : 通过id获取 getElementByTagName() : 通过元素名称获取元素对象们，返回值是一个数组 getElementByClassName() : 通过class属性 获取元素对象们，返回值是一个数组 getElementByClassName() : 通过name属性获取元素对象们，返回值是一个数组 创建其他DOM对象 createAttribute(name) createComment(name) createElement(name) createTextNode(name) 属性 Element 创建 通过document对象进行获取 方法 removeAttribute(): 删除属性 setAttribute(): 设置属性 Node所有的DOM对象都可以认为是一个Node 方法 appendChild() : 向节点的子节点列表的 结尾添加新的子节点。 123var div = document.createElement(&quot;div&quot;);//添加parent.appendChild(div); removeChild() : 删除并返回当前节点的指定节点。 replaceChild() : 用新节点替换一个子节点。 属性 parentNode: 当前节点的父节点 HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准 innerHTMLinnerHTML为该Element内的内容 创建 div.innerHTML 控制样式 element.style.样式名 = XXX; element.classname = &quot;类选择器样式名&quot;; 事件使用123document.getElementById(&quot;input&quot;).onblur = function() { ...} 事件类型 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 onfocus:元素获得焦点。 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown 鼠标按钮被按下。 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件： onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选择和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件： onsubmit 确认按钮被点击。 onreset 重置按钮被点击。 WebServlet1234567891011121314151617181920212223242526272829303132333435public class ServletDemo1 implements Servlet { /** * Servlet创建时调用，只会执行一次 */ @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } /** * Servlet访问一次执行一次 */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;hello Servlet&quot;); } @Override public String getServletInfo() { return null; } /** * 服务器正常关闭时执行 */ @Override public void destroy() { }} 或直接使用Servlet实现类HttpServlet 12345678910111213@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); }} 配置servlet 12345678910&lt;!-- 配置Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!-- 配置映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过以上代码即可实现一个极简的demo servlet的创建时机默认第一次访问时创建可通过配置文件更改为启动时创建 12345&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 其中，当load-on-startup为负数时，则为访问时创建。 为0或正数时为启动时创建 servlet3.0注解配置不在需要在web.xml中配置 123@WebServlet(urlPatterns = &quot;/demo1&quot;)//或简写成@WebServlet(&quot;/demo1&quot;) urlpartten可以配置多个都可以访问到该servlet 1@WebServlet(&quot;/demo1&quot;,&quot;/demo2&quot;,&quot;/demo3&quot;) Request获取请求行数据GET /day14/demo1?name=zhangsan HTTP/1.1 获取请求方式 ：GET String getMethod() 获取虚拟目录：/day14 String getContextPath() 获取Servlet路径: /demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() 一般不会使用这个获取参数 获取请求URI： String getRequestURI(): /day14/demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 URI：统一资源标识符 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 12345678//获取所有请求头信息Enumeration&lt;String&gt; headerNames = req.getHeaderNames();//遍历while (headerNames.hasMoreElements()) { //获取值 String key = headerNames.nextElement(); String value = req.getHeader(key);} 获取请求体数据:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 123456BufferedReader reader = req.getReader();String line;while ((line = reader.readLine()) != null) { System.out.println(line);} 获取请求参数通用方式get还是post请求方式都可以使用来获取请求参数 根据key获取value String getParameter(String name) 根据1个key获取多个值的数组 String[] getParameterValues(String name) 获取所有请求的key Enumeration&lt;String&gt; getParameterNames() 获取所有参数的map集合 Map&lt;String,String[]&gt; getParameterMap() 转发1request.getRequestDispatcher(&quot;url&quot;).forward(request,response); 转发时传递数据 存放数据至Request中 request.setAttribute(&quot;key&quot;,&quot;value:Object&quot;); 获取数据 Object object = request.getAttribute(&quot;key&quot;); 移除键值对 request.removeAttribute(&quot;key&quot;); Response 设置响应状态码 setStatus(int code); 设置响应头 setHeader(&quot;key&quot;,&quot;value&quot;); 设置返回数据返回字符数据12345678910//获取流之前 ，设置流的编码response.setCharactereEncoding(&quot;utf-8&quot;);//告诉浏览器使用什么编码解码response.setHeader(&quot;content-type&quot;,&quot;text/html;chaset=utf-8&quot;);//或者直接使用response.setContentType(&quot;text/html;chaset=utf-8&quot;);//获取字符输出流PrintWriter pw = response.getWriter();//输出字符pw.write(&quot;str&quot;); 返回字节数据12ServletOutputStream sos=response.getOutputStream();sos.write(&quot;str&quot;.getBytes()); 设置弹出下载文件提示框设置响应头 12setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=xxx&quot;); 重定向 使用sendRedirect 1response.sendRedirect(&quot;url&quot;); 设置响应码与响应头完成重定向 123response.setStatus(302);response.setHeader(&quot;location&quot;,&quot;url&quot;); 重定向与转发的特点与区别转发 地址栏路径不变 只能转发当前服务器的地址 转发时一次请求 可以使用request共享数据 重定向 地址栏发生改变 可以跳转任意网址 是俩次请求 不可以共享数据 使用地址时的注意事项 地址是给服务器自身用的 可以不加虚拟目录 地址是给浏览器用的 需要加虚拟目录 request.getContextPath()获取虚拟目录 ServletContext代表整个web应用，可以和服务器通信 获取ServletContext 通过request获取: request.getServletContext(); 通过HttpServlet获取: this.getServletContext(); 功能 获取MIME类型: String mimeType = getMimeType(&quot;filename&quot;) 本质上是根据文件的后缀从而在对应关系表中查询 共享数据 存放数据 setAttribute(&quot;key&quot;,&quot;value:Object&quot;); 获取数据 getAttribute(&quot;key&quot;); 移除键值对 removeAttribute(&quot;key&quot;); 作用范围：整个服务器中所有的请求，所有的用户 获取文件的真实路径 123context.getRealPath(&quot;/filename.xxx&quot;); // 项目目录下的文件context.getRealPath(&quot;/WEB-INF/filename.xxx&quot;); // WEB-INF目录下的文件context.getRealPath(&quot;/WEB-INF/classes/filename.xxx&quot;); // src目录下的文件 Cookie客户端会话技术(数据保存在本地) 基本使用 添加cookie信息 12Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);response.addCookie(cookie); 服务器添加了 cookie后，会在响应头中添加set-cookie:cookieKey=cookieValue。 获取cookie 当浏览器在一次请求中的响应数据中读到了set-cookie，那么当下次请求的时候会通过添加请求头cookie:key=value 服务器中获取 1Cookie[] cookies = request.getCookies(); 存活时间默认存在内存中，为当浏览器被关闭则失效，可通过cookie.setMaxAge()更改。 参数为正数 将cookie持久化到磁盘，并存活响应的秒数。 参数为0 删除cookie 参数为负数 更改为默认模式，当浏览器关闭则失效 作用范围默认为只有当前虚拟目录下的可以获取。可通过cookie.setPath(&quot;path&quot;)来设置需要cookie的作用目录 不同的服务器项目可通过setDomain来设置 特点 存放到浏览器 单个大小一般不能超过4k 同一个域名数量一般不能超过20个 Session服务器会话技术，在一次会话的多次请求中共享数据，数据保存到服务器的HttpSession对象中 使用 获取HttpSession： HttpSession session = request.getSession(); 使用HttpSession对象： 存放数据 setAttribute(&quot;key&quot;,&quot;value:Object&quot;); 获取数据 getAttribute(&quot;key&quot;); 移除键值对 removeAttribute(&quot;key&quot;); 原理session是依赖于cookie的 获取Session时，会判断cookie中是否含有JSESSIONID,如果没有，则说明为第一次访问，会创建一个Session，并将其id塞入响应头的set-cookie中。当cookie中含有一个JSESSIONID时，根据该id进行获取Session对象 钝化和活化当服务器需要重新启动时，为了保证Session不丢失，需要将Session序列化到本地也就是钝化。重新读取至内存为活化 Tomcat会自动进行钝化和活化。 销毁时机 服务器被关闭 自身调用invalidate() 超出设置的时长，默认为30分钟。可通过在web.xml中更改 123 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 特点 存在服务器 可以存任意类型、任意大小的数据 JSP既可以写htnl标签，又可以写java代码，本质上是一个Servlet 指令格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 分类： page： 配置JSP页面的 contentType：等同于response.setContentType() import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前是否是错误页面,表示后可以使用内置对象exception。 include：导入其他页面 &lt;%@include file=&quot;top.jsp&quot;%&gt; taglib ： 导入jstl等资源 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; prefix：前缀，自定义的 脚本3中定义脚本的方式 &lt;% 代码 %&gt; 会转换为service中的语句 &lt;%! 代码 %&gt; 会转换为类的成员变量位置的代码 &lt;%= 语句 %&gt; 输出语句,会输入到页面上 内置对象在jsp中不需要获取和创建，可直接使用的对象 域对象 PageContext pageContext 当前页面共享数据,并可以获取其他内置对象 HttpServletRequest request HttpSession session ServletContext application 其他对象 HttpServletResponse response JspWriter out 字符输出流对象，可以将数据输出到页面上，和response.getWriter()类似,不过输出内容会受位置的影响。 (Servlet)Object page ServletConfig config Throwable exception EL表达式用于替换和简化jsp页面中java代码的编写 语法：${表达式} 运算： 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty、not empty 获取值 ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope—对应的域对象—-&gt; pageContext requestScope—对应的域对象—-&gt;request sessionScope—对应的域对象—-&gt;session applicationScope—对应的域对象—-&gt;application 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[&quot;key名称&quot;]} 隐式对象：el表达式中有11个隐式对象 注意：jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. \\${表达式} ：忽略当前这个el表达式 jstl表达式JavaServer Pages Tag Library JSP标准标签库 用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 使用标签 常用的JSTL标签 if:相当于java代码的if语句 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach:相当于java代码的for语句 Filter会在配置中的Servlet之前执行,并在Servlet执行完成后执行doFilter后的代码 实现Filter接口 配置拦截路径 注解配置 @WebFilter(&quot;url&quot;) @WebFilter(value = &quot;/*&quot;,dispatcherTypes = DispatcherType.REQUEST) web.xml配置 12345678910&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;FilterDemo&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;url&lt;/url-pattern&gt; &lt;!-- 拦截方式配置 --&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 放行12345@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //放行 filterChain.doFilter(servletRequest,servletResponse);} 5种拦截方式 dispatcherTypes REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 多个拦截器执行顺序问题 按类名的字符以此比较，小的先执行 xml配置的位置，从上到下执行 Listener监听ServletContext对象的创建和销毁 一般用于加载资源文件 实现ServletContextListener接口 配置 xml 123&lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 注解 @WebListener","link":"/2021/03/26/JavaWeb%E7%AC%94%E8%AE%B0/"},{"title":"Unity2019与Android混合开发","text":"0. 开始前的版本对齐Unity版本：Unity2019.3.4f1AndroidStudio版本：3.5.3 1. Unity – 准备项目 新建项目 打开File -&gt; Build Setting 切换工程模式首先选择Android Platform，然后点击Switch Platform切换工程模式。 导出Android工程先勾上Export Project，否则下方的Export按钮会是一个Build，点击后Unity会直接导出一个Apk文件，而并不是一个Android Studio项目。点击Export后，选择保存位置后会成功输出一个Android Studio项目，此时Unity的操作告一段落。 2. Android 打开项目在使用Android studio 打开项目时，会跳出一个选择SDK的选项，此处我选择使用Android Studio’s SDK。Project’s SDK是Unity提供的，我觉得用此SDK可能对原生开发会有一定的影响。我并没有使用Project’s SDK进行验证。 然后在弹出的Gradle 同步提示框中点击OK后项目就开始同步，如果无错误就可以进行开发了 3. Android 项目结构Gradle同步完成后，可以看到以下目录（从Android视图切换为了Project） 其中launcher为平时Android开发中app主module，推荐在launcher主module中开发新的逻辑。（java目录需要自行创建）。 unityLibrary为Unity生成的子module。在unityLibrary中包含一个UnityPlayerActivity的示例Activity，在不进行修改任何代码的时候默认启动的Activity就是这个UnityPlayerActivity。(可以在AndroidManifest中看到将这个activity配置成了启动Acitivity) 而在unityLibrary module中的lib目录中可以看到有一个unity-classes.jar，一个非常重要的类UnityPlayer就是来自这个jar包。如果之前已经在Unity项目中添加过一些Android插件，在lib目录下也会出现这些其他的lib包。 那么我们来看下UnityPlayerActivity这个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINpackage com.unity3d.player;import android.app.Activity;import android.content.Intent;import android.content.res.Configuration;import android.graphics.PixelFormat;import android.os.Bundle;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.view.Window;import android.view.WindowManager;import android.os.Process;public class UnityPlayerActivity extends Activity implements IUnityPlayerLifecycleEvents{ protected UnityPlayer mUnityPlayer; // don't change the name of this variable; referenced from native code // Override this in your custom UnityPlayerActivity to tweak the command line arguments passed to the Unity Android Player // The command line arguments are passed as a string, separated by spaces // UnityPlayerActivity calls this from 'onCreate' // Supported: -force-gles20, -force-gles30, -force-gles31, -force-gles31aep, -force-gles32, -force-gles, -force-vulkan // See https://docs.unity3d.com/Manual/CommandLineArguments.html // @param cmdLine the current command line arguments, may be null // @return the modified command line string or null protected String updateUnityCommandLineArguments(String cmdLine) { return cmdLine; } // Setup activity layout @Override protected void onCreate(Bundle savedInstanceState) { requestWindowFeature(Window.FEATURE_NO_TITLE); super.onCreate(savedInstanceState); String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra(&quot;unity&quot;)); getIntent().putExtra(&quot;unity&quot;, cmdLine); mUnityPlayer = new UnityPlayer(this, this); setContentView(mUnityPlayer); mUnityPlayer.requestFocus(); } // When Unity player unloaded move task to background @Override public void onUnityPlayerUnloaded() { moveTaskToBack(true); } // When Unity player quited kill process @Override public void onUnityPlayerQuitted() { Process.killProcess(Process.myPid()); } @Override protected void onNewIntent(Intent intent) { // To support deep linking, we need to make sure that the client can get access to // the last sent intent. The clients access this through a JNI api that allows them // to get the intent set on launch. To update that after launch we have to manually // replace the intent with the one caught here. setIntent(intent); mUnityPlayer.newIntent(intent); } // Quit Unity @Override protected void onDestroy () { mUnityPlayer.destroy(); super.onDestroy(); } // Pause Unity @Override protected void onPause() { super.onPause(); mUnityPlayer.pause(); } // Resume Unity @Override protected void onResume() { super.onResume(); mUnityPlayer.resume(); } // Low Memory Unity @Override public void onLowMemory() { super.onLowMemory(); mUnityPlayer.lowMemory(); } // Trim Memory Unity @Override public void onTrimMemory(int level) { super.onTrimMemory(level); if (level == TRIM_MEMORY_RUNNING_CRITICAL) { mUnityPlayer.lowMemory(); } } // This ensures the layout will be correct. @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); mUnityPlayer.configurationChanged(newConfig); } // Notify Unity of the focus change. @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); mUnityPlayer.windowFocusChanged(hasFocus); } // For some reason the multiple keyevent type is not supported by the ndk. // Force event injection by overriding dispatchKeyEvent(). @Override public boolean dispatchKeyEvent(KeyEvent event) { if (event.getAction() == KeyEvent.ACTION_MULTIPLE) return mUnityPlayer.injectEvent(event); return super.dispatchKeyEvent(event); } // Pass any events not handled by (unfocused) views straight to UnityPlayer @Override public boolean onKeyUp(int keyCode, KeyEvent event) { return mUnityPlayer.injectEvent(event); } @Override public boolean onKeyDown(int keyCode, KeyEvent event) { return mUnityPlayer.injectEvent(event); } @Override public boolean onTouchEvent(MotionEvent event) { return mUnityPlayer.injectEvent(event); } /*API12*/ public boolean onGenericMotionEvent(MotionEvent event) { return mUnityPlayer.injectEvent(event); }} 其中UnityPlayer mUnityPlayer就是Unity最终绘制内容的View（是一个FrameLayout），而UnityPlayerActivity 将这个View设置为自己的根View，进行显示。所以也可以自定义一个任意大小的布局，将mUnityPlayer当做正常的View 添加到布局中，进行自定义大小的控制。而UnityPlayerActivity 也重写了onResume、onPause等进行了对mUnityPlayer生命周期的管理。 4. Android与Unity跳转一般情况下，混合开发都是会先启动原生界面，然后通过点击原生的中button根据业务逻辑跳转至包含Unity的Activity。这样我们就不能将UnityPlayerActivity设置为第一个启动的Activity。 取消UnityPlayerActivity默认启动在AndroidManifest文件中删除或注释掉UnityPlayerActivity配置的下intent-filter小伙伴如果之前已经在Unity中导入了其他Android插件，那么这个AndroidManifest中显示的Activity应该是插件中自定义的Activity，而不是UnityPlayerActivity，注释掉相应的代码即可。 页面跳转通过常规的startActivity即可启动UnityPlayerActivity12345678910findViewById(R.id.btn_button1).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new Intent(HomeActivity.this, UnityPlayerActivity.class); startActivity(intent); }}); 但是，当你finish到这个UnityPlayerActivity时你会发现，即使还有Activity显示，应用还是自动关闭了。这个问题是因为在UnityPlayerActivity中的onDestroy方法中调用了mUnityPlayer中destroy方法。1234567// Quit Unity@Override protected void onDestroy (){ mUnityPlayer.destroy(); super.onDestroy();} 我们点进mUnityPlayer.destroy()看一下 1234567891011121314public void destroy() { //...省略无用代码 if (this.mProcessKillRequested) { if (this.m_UnityPlayerLifecycleEvents != null) { this.m_UnityPlayerLifecycleEvents.onUnityPlayerQuitted(); } else { this.onUnityPlayerQuitted(); } Process.killProcess(Process.myPid()); // 结束自己的进程 } unloadNative();} 发现在mProcessKillRequested 为true的时候，会进行一个杀自己进程的操作，而我们一般app都是一个进程，就会导致我们的app被kill掉。解决办法就是在AndroidManifest配置一下UnityPlayerActivity，UnityPlayerActivity以一个新的进程启动。 1android:process=&quot;:e.unitry3d&quot; Android多进程总结一:生成多进程(android:process属性) 5. Android 自定义Unity显示形式由于业务的需求决定，混合开发中的Unity不一定为全屏幕显示或者可能需要多个Unity界面，那么就需要继承UnityPlayerActivity进行自定义一个显示Unity的界面。 当我们的业务需求决定了我们需要实现一个UnityPlayerActivity的子类进行扩展功能的时候，需要进行以下步骤： 禁止UnityPlayerActivity中添加mUnityPlayer在UnityPlayerActivity的onCreate中注释setContentView和requestFocus代码,因为要在子类中按需加载mUnityPlayer，防止多次设置View，就注释掉父类的相关代码。 1234567891011121314// Setup activity layout@Override protected void onCreate(Bundle savedInstanceState){ requestWindowFeature(Window.FEATURE_NO_TITLE); super.onCreate(savedInstanceState); String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra(&quot;unity&quot;)); getIntent().putExtra(&quot;unity&quot;, cmdLine); mUnityPlayer = new UnityPlayer(this, this); //setContentView(mUnityPlayer); //mUnityPlayer.requestFocus();} 实现子类，将mUnityPlayer设置给布局 123456789101112131415public class UnityActivity extends UnityPlayerActivity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.layout_unity); FrameLayout frameLayout = findViewById(R.id.framelayout); frameLayout.addView(mUnityPlayer); mUnityPlayer.requestFocus(); }} 或 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(mUnityPlayer); mUnityPlayer.requestFocus();} 这个地方需要注意两点：1.如果之前导入过插件，这里一定要继承自插件中实现的UnityPlayerActivity子类，否则，插件的方法不会被调用。2. 记得要将实现的Activity配置为新的进程。 如果想启动不同的Unity界面，也不需要实现多个Activity子类，和Unity开发约定下通信规则，确定好发送什么参数启动什么页面，在Activity启动后调用相关的方法，发送约定好的参数即可。 例如：启动界面： 123456789findViewById(R.id.btn_button1).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new Intent(HomeActivity.this, UnityActivity.class); intent.putExtra(&quot;panelName&quot;,&quot;LunchPanel&quot;); startActivity(intent); }}); UnityActivity 12345678910protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(mUnityPlayer); mUnityPlayer.requestFocus(); String panelName = getIntent().getStringExtra(&quot;panelName&quot;); UnityPlayer.UnitySendMessage(&quot;UIRoot&quot;,&quot;openPanel&quot;,panelName);//unity方法} 6. 使用Fragment当做Unity显示的载体目前我试出来的方案就是将mUnityPlayer在Fragment将要挂载的Activity中进行创建并进行生命周期的管理。 Activity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class HomeActivity extends FragmentActivity { protected UnityPlayer mUnityPlayer; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.home_activity); mUnityPlayer = new UnityPlayer(this, null); FragmentManager fragmentManager = getSupportFragmentManager(); fragmentManager.beginTransaction().add(R.id.fl,new UnityFragment(mUnityPlayer)).commit(); } @Override protected void onNewIntent(Intent intent) { // To support deep linking, we need to make sure that the client can get access to // the last sent intent. The clients access this through a JNI api that allows them // to get the intent set on launch. To update that after launch we have to manually // replace the intent with the one caught here. setIntent(intent); mUnityPlayer.newIntent(intent); } // Quit Unity @Override protected void onDestroy () { mUnityPlayer.destroy(); //mUnityPlayer.unloadNative(); super.onDestroy(); } // Pause Unity @Override protected void onPause() { super.onPause(); mUnityPlayer.pause(); } // Resume Unity @Override protected void onResume() { super.onResume(); mUnityPlayer.resume(); } // Low Memory Unity @Override public void onLowMemory() { super.onLowMemory(); mUnityPlayer.lowMemory(); } // Trim Memory Unity @Override public void onTrimMemory(int level) { super.onTrimMemory(level); if (level == TRIM_MEMORY_RUNNING_CRITICAL) { mUnityPlayer.lowMemory(); } } // This ensures the layout will be correct. @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); mUnityPlayer.configurationChanged(newConfig); } // Notify Unity of the focus change. @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); mUnityPlayer.windowFocusChanged(hasFocus); } // For some reason the multiple keyevent type is not supported by the ndk. // Force event injection by overriding dispatchKeyEvent(). @Override public boolean dispatchKeyEvent(KeyEvent event) { if (event.getAction() == KeyEvent.ACTION_MULTIPLE) return mUnityPlayer.injectEvent(event); return super.dispatchKeyEvent(event); } // Pass any events not handled by (unfocused) views straight to UnityPlayer @Override public boolean onKeyUp(int keyCode, KeyEvent event) { return mUnityPlayer.injectEvent(event); } @Override public boolean onKeyDown(int keyCode, KeyEvent event) { return mUnityPlayer.injectEvent(event); } @Override public boolean onTouchEvent(MotionEvent event) { return mUnityPlayer.injectEvent(event); } /*API12*/ public boolean onGenericMotionEvent(MotionEvent event) { return mUnityPlayer.injectEvent(event); }} fragment 123456789101112131415161718public class UnityFragment extends Fragment{ private UnityPlayer mUnityPlayer; public UnityFragment(UnityPlayer unityPlayer) { mUnityPlayer = unityPlayer; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return mUnityPlayer; }} 7. Unity与Android之间的通讯此内容网络上已有较多文章，本文不再叙述。 8. 注意事项 当Unity与Android同时开发时，每次从Unity导出新的项目覆盖之前的老代码的时候主launcher中的AndroidManifest文件会被重置，导出前务必要备份。 文章可能因为个人能力原因出现错误，忘谅解。希望能够指出。","link":"/2021/03/26/Unity2019%E4%B8%8EAndroid%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"},{"title":"Gradle构建流程分析（一）- 初始化与Task创建","text":"基于AGP3.4.2版本进行分析 获取源码在build.gradle中添加implementation 'com.android.tools.build:gradle:3.4.2'Sync后即可看到源码 插件入口获取到源码后，看/META-INF/gradle-plugins/com.android.application.properties文件内容为 1implementation-class=com.android.build.gradle.AppPlugin 可以看出插件“com.android.application”对应为AppPlugin.java，在同级目录下的com.android.library.properties文件 1implementation-class=com.android.build.gradle.LibraryPlugin 可以看出插件“com.android.library”为LibraryPlugin.java 核心逻辑AppPlugin与LibraryPlugin中并没有实现Plugin#apply()方法，该方法是由其父类BasePlugin实现 1234567891011//BasePlugin#apply()@Overridepublic final void apply(@NonNull Project project) { CrashReporting.runAction( () -&gt; { // AppPlugin与LibraryPlugin即其他插件通用逻辑 basePluginApply(project); // 子类按需添加的功能 pluginSpecificApply(project); });} pluginSpecificApply为一个抽象方法，供子类在apply()方法中添加自定义功能。AppPlugin中为空实现，在LibraryPlugin中添加了一个assembleDefault的Task。 1234567//LibraryPlugin#pluginSpecificApply()@Overrideprotected void pluginSpecificApply(@NonNull Project project) { // Default assemble task for the default-published artifact. // This is needed for the prepare task on the consuming project. project.getTasks().create(&quot;assembleDefault&quot;);} basePluginApply方法为核心方法，其中处理了整个插件的初始化工作，Gradle版本、依赖检查、预设build任务完成后的清理工作等。其中最重要的是设置Extension与创建Task 12345678910111213141516171819202122232425262728// BasePlugin#basePluginApply()private void basePluginApply(@NonNull Project project) { // ....初始化等工作 // 一个目前试验性的参数，目前还没启用 if (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) { // 创建核心类、下载缺少的sdk等 threadRecorder.record( ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE, project.getPath(), null, this::configureProject); // 创建配置表 threadRecorder.record( ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION, project.getPath(), null, this::configureExtension); // 创建Task threadRecorder.record( ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION, project.getPath(), null, this::createTasks); } else { // ... }} 其中需要重点关注3个方法configureProject(),configureExtension(),createTasks()。 配置环境 - configureProject()configureProject中创建了下文所需的androidBuilder、globalScope核心类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// BasePlugin#configureProject()private void configureProject() { // .... extraModelInfo = new ExtraModelInfo(project.getPath(), projectOptions, project.getLogger()); sdkHandler = new SdkHandler(project, getLogger()); // 下载缺少的sdk if (!gradle.getStartParameter().isOffline() &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)) { SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController()); sdkHandler.setSdkLibData(sdkLibData); } // 创建主构建器，合并menifest、合并resources等实现都是由该类完成的 AndroidBuilder androidBuilder = new AndroidBuilder( project == project.getRootProject() ? project.getName() : project.getPath(), creator, new GradleProcessExecutor(project), new GradleJavaProcessExecutor(project), extraModelInfo.getSyncIssueHandler(), extraModelInfo.getMessageReceiver(), getLogger()); // DataBinding相关 dataBindingBuilder = new DataBindingBuilder(); // ..... // 全局的数据存储 globalScope = new GlobalScope( project, new ProjectWrapper(project), projectOptions, dslScope, androidBuilder, sdkHandler, registry, buildCache); project.getTasks() .getByName(&quot;assemble&quot;) .setDescription( &quot;Assembles all variants of all applications and secondary packages.&quot;); // call back on execution. This is called after the whole build is done (not // after the current project is done). // This is will be called for each (android) projects though, so this should support // being called 2+ times. gradle.addBuildListener( new BuildListener() { @Override public void buildStarted(@NonNull Gradle gradle) {} @Override public void settingsEvaluated(@NonNull Settings settings) {} @Override public void projectsLoaded(@NonNull Gradle gradle) {} @Override public void projectsEvaluated(@NonNull Gradle gradle) {} @Override public void buildFinished(@NonNull BuildResult buildResult) { // Do not run buildFinished for included project in composite build. // 清理工作 if (buildResult.getGradle().getParent() != null) { return; } ModelBuilder.clearCaches(); sdkHandler.unload(); threadRecorder.record( ExecutionType.BASE_PLUGIN_BUILD_FINISHED, project.getPath(), null, () -&gt; { WorkerActionServiceRegistry.INSTANCE .shutdownAllRegisteredServices( ForkJoinPool.commonPool()); Main.clearInternTables(); }); DeprecationReporterImpl.Companion.clean(); } }); createLintClasspathConfiguration(project);} 创建Extension - configureExtension()在configureExtension中创建了Extension，使得我们可以在build.gradle中的使用这样的代码块 12345678android{ buildToolsVersion '28.0.3' defaultConfig { applicationId &quot;com.xxx&quot; versionCode 1157 }} Extension详解可以参照官方文档：Gradle Plugin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// BasePlugin#configureExtension()private void configureExtension() { ObjectFactory objectFactory = project.getObjects(); // buildTypes final NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer = project.container( BuildType.class, new BuildTypeFactory( objectFactory, project, extraModelInfo.getSyncIssueHandler(), extraModelInfo.getDeprecationReporter())); // productFlavors final NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer = project.container( ProductFlavor.class, new ProductFlavorFactory( objectFactory, project, extraModelInfo.getDeprecationReporter(), project.getLogger())); // signingConfigs final NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer = project.container( SigningConfig.class, new SigningConfigFactory( objectFactory, GradleKeystoreHelper.getDefaultDebugKeystoreLocation())); final NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs = project.container(BaseVariantOutput.class); project.getExtensions().add(&quot;buildOutputs&quot;, buildOutputs); // sourceSets 可以配置资源的位置， sourceSetManager = new SourceSetManager( project, isPackagePublished(), globalScope.getDslScope(), new DelayedActionsExecutor()); // 根据子类创建Extension extension = createExtension( project, projectOptions, globalScope, sdkHandler, buildTypeContainer, productFlavorContainer, signingConfigContainer, buildOutputs, sourceSetManager, extraModelInfo); // 存储到globalScope中 globalScope.setExtension(extension); // 针对app、lib进行不同的实现 variantFactory = createVariantFactory(globalScope, extension); // 创建TaskManager taskManager = createTaskManager( globalScope, project, projectOptions, dataBindingBuilder, extension, sdkHandler, variantFactory, registry, threadRecorder); variantManager = new VariantManager( globalScope, project, projectOptions, extension, variantFactory, taskManager, sourceSetManager, threadRecorder); registerModels(registry, globalScope, variantManager, extension, extraModelInfo); // 每一个signingConfigs配置即会调用一次addSigningConfig，使得将所有的签名文件存放到一个map中。 // 即使不配置signingConfigs也会有一个默认的DEBUG签名。 // map the whenObjectAdded callbacks on the containers. signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig); buildTypeContainer.whenObjectAdded( buildType -&gt; { if (!this.getClass().isAssignableFrom(DynamicFeaturePlugin.class)) { SigningConfig signingConfig = signingConfigContainer.findByName(BuilderConstants.DEBUG); // 将项目的默认签名设置为DEBUG签名 buildType.init(signingConfig); } else { // initialize it without the signingConfig for dynamic-features. buildType.init(); } variantManager.addBuildType(buildType); }); // 每个flavor也会调用addProductFlavor方法，分析每个flavor中独立配置的参数列表， // 包括这个flover独立的minSdkVersion、targetSdkVersion等，构建一个ProductFlavorData数据 productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor); // map whenObjectRemoved on the containers to throw an exception. signingConfigContainer.whenObjectRemoved( new UnsupportedAction(&quot;Removing signingConfigs is not supported.&quot;)); buildTypeContainer.whenObjectRemoved( new UnsupportedAction(&quot;Removing build types is not supported.&quot;)); productFlavorContainer.whenObjectRemoved( new UnsupportedAction(&quot;Removing product flavors is not supported.&quot;)); // 在signingConfig创建一个debug dsl，在buildTypes中创建debug、release的dsl // create default Objects, signingConfig first as its used by the BuildTypes. variantFactory.createDefaultComponents( buildTypeContainer, productFlavorContainer, signingConfigContainer);} 在configureExtension方法中，首先配置了我们经常在build.gradle中看到的一些参数，例如signingConfigs、productFlavors等，并通过whenObjectAdded监听将填入的数据收集到variantManager中的map中。在抽象方法createExtension中会根据子类的不同进行创建不同的Extension。具体都是直接调用project.getExtensions().create(&quot;android&quot;,getExtensionClass(),xxxxxx)方法进行创建，AppPlugingetExtensionClass()返回的是BaseAppModuleExtension.class，LibraryPlugin方法返回的是LibraryExtension.class。 1234567891011// AppPlugin#getExtensionClass()@Override@NonNullprotected Class&lt;? extends AppExtension&gt; getExtensionClass() { return BaseAppModuleExtension.class;}// LibraryPlugin#getExtensionClass()@NonNullprotected Class&lt;? extends BaseExtension&gt; getExtensionClass() { return LibraryExtension.class;} 同时，也创建了createTasks方法中所需的参数：taskManager、variantManager。 创建Task列表-createTasks()1234567891011121314151617181920private void createTasks() { threadRecorder.record( ExecutionType.TASK_MANAGER_CREATE_TASKS, project.getPath(), null, () -&gt; taskManager.createTasksBeforeEvaluate()); // 创建一些不依赖flover的Task project.afterEvaluate( CrashReporting.afterEvaluate( p -&gt; { // 执行延时任务，一般为空任务 sourceSetManager.runBuildableArtifactsActions(); threadRecorder.record( ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS, project.getPath(), null, this::createAndroidTasks);// 开始创建核心Task }));} 在taskManager.createTasksBeforeEvaluate()中，创建了preBuild、lint相关的task。构建核心task是在createAndroidTasks方法中创建的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@VisibleForTestingfinal void createAndroidTasks() { // ... 参数的检查与设置 // lint taskManager.configureCustomLintChecks(); // ... // 创建Task的核心方法，会对buildTypes 和 flover进行组合，并创建合并后tasks List&lt;VariantScope&gt; variantScopes = variantManager.createAndroidTasks(); ApiObjectFactory apiObjectFactory = new ApiObjectFactory( globalScope.getAndroidBuilder(), extension, variantFactory, project.getObjects()); for (VariantScope variantScope : variantScopes) { BaseVariantData variantData = variantScope.getVariantData(); apiObjectFactory.create(variantData); } // Make sure no SourceSets were added through the DSL without being properly configured // Only do it if we are not restricting to a single variant (with Instant // Run or we can find extra source set if (projectOptions.get(StringOption.IDE_RESTRICT_VARIANT_NAME) == null) { sourceSetManager.checkForUnconfiguredSourceSets(); } // must run this after scopes are created so that we can configure kotlin // kapt tasks taskManager.addDataBindingDependenciesIfNecessary( extension.getDataBinding(), variantManager.getVariantScopes()); // create the global lint task that depends on all the variants taskManager.configureGlobalLintTask(variantManager.getVariantScopes()); int flavorDimensionCount = 0; if (extension.getFlavorDimensionList() != null) { flavorDimensionCount = extension.getFlavorDimensionList().size(); } taskManager.createAnchorAssembleTasks( variantScopes, extension.getProductFlavors().size(), flavorDimensionCount, variantFactory.getVariantConfigurationTypes().size()); // now publish all variant artifacts. for (VariantScope variantScope : variantManager.getVariantScopes()) { variantManager.publishBuildArtifacts(variantScope); } checkSplitConfiguration(); variantManager.setHasCreatedTasks(true);} 1234567891011121314151617181920212223public List&lt;VariantScope&gt; createAndroidTasks() { variantFactory.validateModel(this); variantFactory.preVariantWork(project); if (variantScopes.isEmpty()) { // 拼接flover与buildType populateVariantDataList(); } // Create top level test tasks. taskManager.createTopLevelTestTasks(!productFlavors.isEmpty()); for (final VariantScope variantScope : variantScopes) { // 根据每个组合创建Task createTasksForVariantData(variantScope); } taskManager.createSourceSetArtifactReportTask(globalScope); taskManager.createReportTasks(variantScopes); return variantScopes;} 12345678910111213141516171819public void createTasksForVariantData(final VariantScope variantScope) { final BaseVariantData variantData = variantScope.getVariantData(); final VariantType variantType = variantData.getType(); final GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration(); // 与variantData拼接名称创建assembleTask taskManager.createAssembleTask(variantData); if (variantType.isBaseModule()) { taskManager.createBundleTask(variantData); } if (variantType.isTestComponent()) { // ... } else { // 创建其他Task taskManager.createTasksForVariantScope(variantScope); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// ApplicationTaskManager#createTasksForVariantScope()@Overridepublic void createTasksForVariantScope(@NonNull final VariantScope variantScope) { createAnchorTasks(variantScope); createCheckManifestTask(variantScope); handleMicroApp(variantScope); // Create all current streams (dependencies mostly at this point) createDependencyStreams(variantScope); // Add a task to publish the applicationId. createApplicationIdWriterTask(variantScope); taskFactory.register(new MainApkListPersistence.CreationAction(variantScope)); createBuildArtifactReportTask(variantScope); // Add a task to process the manifest(s) createMergeApkManifestsTask(variantScope); // Add a task to create the res values createGenerateResValuesTask(variantScope); // Add a task to compile renderscript files. createRenderscriptTask(variantScope); // Add a task to merge the resource folders createMergeResourcesTask( variantScope, true, Sets.immutableEnumSet(MergeResources.Flag.PROCESS_VECTOR_DRAWABLES)); // Add tasks to compile shader createShaderTask(variantScope); // Add a task to merge the asset folders createMergeAssetsTask(variantScope); // Add a task to create the BuildConfig class createBuildConfigTask(variantScope); // Add a task to process the Android Resources and generate source files createApkProcessResTask(variantScope); // Add a task to process the java resources createProcessJavaResTask(variantScope); createAidlTask(variantScope); // Add external native build tasks createExternalNativeBuildJsonGenerators(variantScope); createExternalNativeBuildTasks(variantScope); // Add a task to merge the jni libs folders createMergeJniLibFoldersTasks(variantScope); // Add feature related tasks if necessary if (variantScope.getType().isBaseModule()) { // Base feature specific tasks. taskFactory.register(new FeatureSetMetadataWriterTask.CreationAction(variantScope)); createValidateSigningTask(variantScope); // Add a task to produce the signing config file. taskFactory.register(new SigningConfigWriterTask.CreationAction(variantScope)); if (extension.getDataBinding().isEnabled()) { // Create a task that will package the manifest ids(the R file packages) of all // features into a file. This file's path is passed into the Data Binding annotation // processor which uses it to known about all available features. // // &lt;p&gt;see: {@link TaskManager#setDataBindingAnnotationProcessorParams(VariantScope)} taskFactory.register( new DataBindingExportFeatureApplicationIdsTask.CreationAction( variantScope)); } } else { // Non-base feature specific task. // Task will produce artifacts consumed by the base feature taskFactory.register( new FeatureSplitDeclarationWriterTask.CreationAction(variantScope)); if (extension.getDataBinding().isEnabled()) { // Create a task that will package necessary information about the feature into a // file which is passed into the Data Binding annotation processor. taskFactory.register( new DataBindingExportFeatureInfoTask.CreationAction(variantScope)); } taskFactory.register(new MergeConsumerProguardFilesTask.CreationAction(variantScope)); } // Add data binding tasks if enabled createDataBindingTasksIfNecessary(variantScope, MergeType.MERGE); // Add a compile task createCompileTask(variantScope); createStripNativeLibraryTask(taskFactory, variantScope); if (variantScope.getVariantData().getMultiOutputPolicy().equals(MultiOutputPolicy.SPLITS)) { if (extension.getBuildToolsRevision().getMajor() &lt; 21) { throw new RuntimeException( &quot;Pure splits can only be used with buildtools 21 and later&quot;); } createSplitTasks(variantScope); } TaskProvider&lt;BuildInfoWriterTask&gt; buildInfoWriterTask = createInstantRunPackagingTasks(variantScope); createPackagingTask(variantScope, buildInfoWriterTask); // Create the lint tasks, if enabled createLintTasks(variantScope); taskFactory.register(new FeatureSplitTransitiveDepsWriterTask.CreationAction(variantScope)); createDynamicBundleTask(variantScope);}","link":"/2022/01/12/gradle%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/"},{"title":"Android焦点机制","text":"本篇所分析的源码为Android 28，可能与其他版本有所出入 焦点存储与设置焦点的标志位在View中，自身的许多状态都是使用mPrivateFlags来记录，其中FOCUSABLE_MASK位为记录View的焦点状态 View.java1234/** * Mask for use with setFlags indicating bits used for focus. */private static final int FOCUSABLE_MASK = 0x00000011; View的焦点焦点状态共有3种NOT_FOCUSABLE、FOCUSABLE、FOCUSABLE_AUTO。 View.java1234567891011121314/** * This view does not want keystrokes. */public static final int NOT_FOCUSABLE = 0x00000000;/** * This view wants keystrokes. */public static final int FOCUSABLE = 0x00000001;/** * This view determines focusability automatically. This is the default. */public static final int FOCUSABLE_AUTO = 0x00000010; 其中FOCUSABLE_AUTO为默认状态，当未在xml未配置android:focusable属性时，系统会将焦点状态设置为FOCUSABLE_AUTO View.java123456789101112131415161718192021222324252627282930313233public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { // ... // 在构造方法中设置默认值为FOCUSABLE_AUTO viewFlagValues |= FOCUSABLE_AUTO; viewFlagMasks |= FOCUSABLE_AUTO; // ... // 获取xml中配置的focusable的值 case com.android.internal.R.styleable.View_focusable: viewFlagValues = (viewFlagValues &amp; ~FOCUSABLE_MASK) | getFocusableAttribute(a); if ((viewFlagValues &amp; FOCUSABLE_AUTO) == 0) { // 如果新flag不是FOCUSABLE_AUTO，则更改viewFlagMasks中的标志位，准备在setFlags中更改状态 viewFlagMasks |= FOCUSABLE_MASK; } break; // ... if (viewFlagMasks != 0) { // View状态发生变化进行更新flag setFlags(viewFlagValues, viewFlagMasks); }}private int getFocusableAttribute(TypedArray attributes) { TypedValue val = new TypedValue(); if (attributes.getValue(com.android.internal.R.styleable.View_focusable, val)) { if (val.type == TypedValue.TYPE_INT_BOOLEAN) { return (val.data == 0 ? NOT_FOCUSABLE : FOCUSABLE); } else { return val.data; } } else { return FOCUSABLE_AUTO; // 如果没配置则为FOCUSABLE_AUTO }} 焦点状态的获取View中获取焦点状态即是判断flag中的对应标志位 View.java123public boolean hasFocus() { return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0;} 而在ViewGroup中，存在一个mFocused属性，是当前获取了焦点的子View。但这个mFocused并不是直接就是视图树中当前有焦点的那个View，而是当前这个ViewGroup中的直接子View。当需要获取当前焦点View时，会递归的调用直到找到具体的View。在获取获取焦点状态时，不仅会判断自身是否有焦点，还有判断自己的子View是否也具有焦点。 ViewGroup.java123public boolean hasFocus() { return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0 || mFocused != null;} 焦点状态的设置无论是调用了View.setFocusable(Boolean)还是新版本新增的apiView.setFocusable(int)，最后都是要通过setFlags()方法进行标志位的更改 View.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void setFlags(int flags, int mask) {int old = mViewFlags; mViewFlags = (mViewFlags &amp; ~mask) | (flags &amp; mask); int changed = mViewFlags ^ old; if (changed == 0) { return; } int privateFlags = mPrivateFlags; boolean shouldNotifyFocusableAvailable = false; // If focusable is auto, update the FOCUSABLE bit. int focusableChangedByAuto = 0; if (((mViewFlags &amp; FOCUSABLE_AUTO) != 0) &amp;&amp; (changed &amp; (FOCUSABLE_MASK | CLICKABLE)) != 0) { // Heuristic only takes into account whether view is clickable. final int newFocus; if ((mViewFlags &amp; CLICKABLE) != 0) { newFocus = FOCUSABLE; } else { newFocus = NOT_FOCUSABLE; } mViewFlags = (mViewFlags &amp; ~FOCUSABLE) | newFocus; focusableChangedByAuto = (old &amp; FOCUSABLE) ^ (newFocus &amp; FOCUSABLE); changed = (changed &amp; ~FOCUSABLE) | focusableChangedByAuto; } /* Check if the FOCUSABLE bit has changed */ if (((changed &amp; FOCUSABLE) != 0) &amp;&amp; ((privateFlags &amp; PFLAG_HAS_BOUNDS) != 0)) { if (((old &amp; FOCUSABLE) == FOCUSABLE) &amp;&amp; ((privateFlags &amp; PFLAG_FOCUSED) != 0)) { /* Give up focus if we are no longer focusable */ clearFocus(); if (mParent instanceof ViewGroup) { ((ViewGroup) mParent).clearFocusedInCluster(); } } else if (((old &amp; FOCUSABLE) == NOT_FOCUSABLE) &amp;&amp; ((privateFlags &amp; PFLAG_FOCUSED) == 0)) { /* * Tell the view system that we are now available to take focus * if no one else already has it. */ if (mParent != null) { ViewRootImpl viewRootImpl = getViewRootImpl(); if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) { shouldNotifyFocusableAvailable = canTakeFocus(); } } } }} 焦点事件的产生第一次由系统产生焦点当系统第一次调用到ViewRootImpl.performTraversals()方法时，会创建第一个焦点事件。 ViewRootImpl.java123456789101112131415161718192021222324252627if (mFirst) { // 当系统版本小于28时，sAlwaysAssignFocus为true if (sAlwaysAssignFocus || !isInTouchMode()) { // handle first focus request // mView 为 DecorView if (mView != null) { if (!mView.hasFocus()) { // 将焦点产生在DecorView上 mView.restoreDefaultFocus(); } } } else { // Some views (like ScrollView) won't hand focus to descendants that aren't within // their viewport. Before layout, there's a good change these views are size 0 // which means no children can get focus. After layout, this view now has size, but // is not guaranteed to hand-off focus to a focusable child (specifically, the edge- // case where the child has a size prior to layout and thus won't trigger // focusableViewAvailable). // 确保ScrollView等滑动View的子View会正确的获取到焦点 View focused = mView.findFocus(); if (focused instanceof ViewGroup &amp;&amp; ((ViewGroup) focused).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) { focused.restoreDefaultFocus(); } }} 当系统第一次绘制时，会根据sAlwaysAssignFocus和当前是否为触摸模式进行判断是否产生焦点。sAlwaysAssignFocus会在ViewRootImpl初始化时根据当前版本是否小于Android9被赋值。而其中的mView为添加到Window的DecorView，所以系统第一次产生的焦点默认会产生在根View上，由根View调用restoreDefaultFocus在自己的子view中寻找合适和View，一般为左上角或右下角，由系统页面方向决定。而restoreDefaultFocus本质上就是调用了requestFocus方法。 View.java123public boolean restoreDefaultFocus() { return requestFocus(View.FOCUS_DOWN);} 在Android9前，打开一个包含EditView的Activity时EditView会自动获取焦点，导致软键盘弹出。可通过在父View上配置focusableInTouchMode = true来消除此现象。 应用一般默认处于触摸模式下，当接收到遥控器或其他设备产生的KeyEvent，会切换到非触摸模式下 按键产生焦点当第一次系统处于触摸模式或其他原因导致未产生第一个焦点，那么在按下任意一个按键将产生第一个焦点。 按下键后会触发ViewRootImpl.processKeyEvent。该方法负责了按键事件的分发。 ViewRootImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int processKeyEvent(QueuedInputEvent q) { final KeyEvent event = (KeyEvent)q.mEvent; if (mUnhandledKeyManager.preViewDispatch(event)) { return FINISH_HANDLED; } // Deliver the key to the view hierarchy. // 在视图树上依次分发，判断焦点View是否自行处理KeyEvent， // 如果自定义key事件并返回true，后续不再执行 if (mView.dispatchKeyEvent(event)) { return FINISH_HANDLED; } //一些保护措施 //在View层次结构不消费事件，判断窗口是否有输入事件或者已经停止和销毁 if (shouldDropInputEvent(q)) { return FINISH_NOT_HANDLED; } // This dispatch is for windows that don't have a Window.Callback. Otherwise, // the Window.Callback usually will have already called this (see // DecorView.superDispatchKeyEvent) leaving this call a no-op. if (mUnhandledKeyManager.dispatch(mView, event)) { return FINISH_HANDLED; } int groupNavigationDirection = 0; // 判断是否是前进后退组合键，决定焦点的移动方向 if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_TAB) { if (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON)) { groupNavigationDirection = View.FOCUS_FORWARD; } else if (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON | KeyEvent.META_SHIFT_ON)) { groupNavigationDirection = View.FOCUS_BACKWARD; } } // If a modifier is held, try to interpret the key as a shortcut. if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; !KeyEvent.metaStateHasNoModifiers(event.getMetaState()) &amp;&amp; event.getRepeatCount() == 0 &amp;&amp; !KeyEvent.isModifierKey(event.getKeyCode()) &amp;&amp; groupNavigationDirection == 0) { // 对快捷键进行处理，目前子View只有TextView进行了实现。 if (mView.dispatchKeyShortcutEvent(event)) { return FINISH_HANDLED; } if (shouldDropInputEvent(q)) { return FINISH_NOT_HANDLED; } } // Apply the fallback event policy. if (mFallbackEventHandler.dispatchKeyEvent(event)) { return FINISH_HANDLED; } if (shouldDropInputEvent(q)) { return FINISH_NOT_HANDLED; } // Handle automatic focus changes. if (event.getAction() == KeyEvent.ACTION_DOWN) { if (groupNavigationDirection != 0) { // 执行组合键策略 if (performKeyboardGroupNavigation(groupNavigationDirection)) { return FINISH_HANDLED; } } else { // 执行上下左右键策略 if (performFocusNavigation(event)) { return FINISH_HANDLED; } } } return FORWARD;} 如果用户没有自定义KeyEvent处理事件，则会进行系统的焦点处理机制，在之前没有焦点时，会产生第一个焦点，而如果已经有了焦点，则会根据按键的类型进行焦点的移动。 会根据是按了前进后退键还是上下左右键调用performKeyboardGroupNavigation(direction)或performFocusNavigation(keyEvent),而其内部通过调用mView.restoreDefaultFocus()进行产生焦点。 ViewRootImpl.java123456789// 按下前进后退键private boolean performKeyboardGroupNavigation(int direction) { final View focused = mView.findFocus(); if (focused == null &amp;&amp; mView.restoreDefaultFocus()) { return true; } // ..省略移动焦点代码} ViewRootImpl.java123456789101112131415// 按下上下左右键private boolean performFocusNavigation(KeyEvent event) { // .. 省略判断方向代码 if (direction != 0) { View focused = mView.findFocus(); if (focused != null) { // .. 省略移动代码 } else { if (mView.restoreDefaultFocus()) { return true; } } } return false;} performKeyboardGroupNavigation与performFocusNavigation完整代码分析见焦点的移动 requestFocus() 请求焦点在View中，requestFocus最终是调用了requestFocusNoSearch View.java1234567891011121314151617181920212223242526272829private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) { // need to be focusable // 检测view可见性、layout空间大小等 if (!canTakeFocus()) { return false; } // need to be focusable in touch mode if in touch mode // 判断当前是否为触摸模式与是否配置了focusableInTouchMode = true if (isInTouchMode() &amp;&amp; (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) { return false; } // need to not have any parents blocking us // 判断是否有父View拦截焦点事件 if (hasAncestorThatBlocksDescendantFocus()) { return false; } if (!isLayoutValid()) { mPrivateFlags |= PFLAG_WANTS_FOCUS; } else { clearParentsWantFocus(); } // 处理焦点事件 handleFocusGainInternal(direction, previouslyFocusedRect); return true;} requestFocusNoSearch先通过一系列方法检测该View是否可以获得焦点，最后使用handleFocusGainInternal处理焦点事件。 这里判断了focusableInTouchMode的值，所以当为触摸模式的时候，通过focusableInTouchMode=true也可以使得View获取到焦点，所以大多数文章中使用通过在RecycleView或EditView等自动获取焦点的View的父View上配置这个属性来禁止RecycleView、EditView等自动获取焦点，因为这样可以使父View消耗掉这个焦点事件。 在ViewGroup中，requestFocus有所不同。 ViewGroup.java123456789101112131415161718192021222324252627282930313233343536public boolean requestFocus(int direction, Rect previouslyFocusedRect) { // 获取配置的descendantFocusability int descendantFocusability = getDescendantFocusability(); boolean result; switch (descendantFocusability) { case FOCUS_BLOCK_DESCENDANTS: // 直接请求自己的requestFocus result = super.requestFocus(direction, previouslyFocusedRect); break; case FOCUS_BEFORE_DESCENDANTS: { // 1. 先自行进行请求焦点 final boolean took = super.requestFocus(direction, previouslyFocusedRect); // 2. 如果自己不获取焦点，那么就通过onRequestFocusInDescendants方法分发到子View上 result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect); break; } case FOCUS_AFTER_DESCENDANTS: { // 1. 先通过onRequestFocusInDescendants尝试分发给子View final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect); // 2. 如果子view不获取焦点，那么自己请求焦点 result = took ? took : super.requestFocus(direction, previouslyFocusedRect); break; } default: throw new IllegalStateException(&quot;descendant focusability must be &quot; + &quot;one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS &quot; + &quot;but is &quot; + descendantFocusability); } if (result &amp;&amp; !isLayoutValid() &amp;&amp; ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) == 0)) { mPrivateFlags |= PFLAG_WANTS_FOCUS; } return result;} 在ViewGroup中，判断了自身配置的descendantFocusability的值，其各自所代表的含义为： FOCUS_BLOCK_DESCENDANTS ：仅尝试将焦点分发给当前 ViewGroup FOCUS_BEFORE_DESCENDANTS ：先尝试将焦点分发给当前 ViewGroup，然后才尝试将焦点分发给ChildView。 FOCUS_AFTER_DESCENDANTS ：先尝试将焦点分发给ChildView，然后才尝试将焦点分发给当前 ViewGroup。 View.java123456789101112131415161718192021222324void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) { if ((mPrivateFlags &amp; PFLAG_FOCUSED) == 0) { // 更改焦点标志位 mPrivateFlags |= PFLAG_FOCUSED; // 获取当前已经聚焦的View，用于在监听回调处理相应的逻辑 View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null; if (mParent != null) { // 通知 mParent 焦点变化事件 mParent.requestChildFocus(this, this); updateFocusedInCluster(oldFocus, direction); } if (mAttachInfo != null) { // 通知 ViewTreeObserver 焦点变化事件 mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this); } // 通知当前View焦点变化事件，回调焦点变化监听 onFocusChanged(true, direction, previouslyFocusedRect); // 刷新当前View的状态 refreshDrawableState(); }} 在handleFocusGainInternal方法中，将本View标志位已改为了聚焦的状态，，并通知了一系列监听的变化及状态的改变，但在整个视图树中ViewGroup中存储的mFocues对象的值还并没有修改，该值将会在requestChildFocus方法中进行修改。 View.java12345678910111213141516171819202122232425// ViewGroup.java public void requestChildFocus(View child, View focused) { // 拦截了ChildView的获焦事件，此时焦点不需要继续向上一层级透传 if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) { return; } // Unfocus us, if necessary // 主要作用为如果当前ViewGroup为焦点View，那么清除当前 ViewGroup 的焦点 super.unFocus(focused); // We had a previous notion of who had focus. Clear it. if (mFocused != child) { if (mFocused != null) { // 清除当前存储的View的焦点状态 mFocused.unFocus(focused); } // 更改存储的聚焦的view mFocused = child; } if (mParent != null) { // 这里一层一层向上通知焦点View的改变 mParent.requestChildFocus(this, focused); } } unFocus ViewGroup.java123456789void unFocus(View focused) { // 如果自身是聚焦View，那么清除自身 if (mFocused == null) { super.unFocus(focused); } else { mFocused.unFocus(focused); mFocused = null; }} View.java123456789101112131415161718192021222324void unFocus(View focused) { clearFocusInternal(focused, false, false);}void clearFocusInternal(View focused, boolean propagate, boolean refocus) { if ((mPrivateFlags &amp; PFLAG_FOCUSED) != 0) { // 清除标志位 mPrivateFlags &amp;= ~PFLAG_FOCUSED; clearParentsWantFocus(); // 如果propagate为true，则会向上层层调用清除mFocus的值 // 调用unFocus时为false，调用clearFocus时为true if (propagate &amp;&amp; mParent != null) { mParent.clearChildFocus(this); } // 通知监听 onFocusChanged(false, 0, null); refreshDrawableState(); if (propagate &amp;&amp; (!refocus || !rootViewRequestFocus())) { notifyGlobalFocusCleared(this); } }} 其实此处传入的focused并没有实际作用。 焦点的移动焦点的移动总的来说可以分为这几步。 确定移动方向 寻找到当前具有焦点View 寻找到需要接受焦点的View 切换View的状态 组合键焦点移动在前进后退组合键触发的焦点移动中，移动方向已经在processKeyEvent中确定。 ViewRootImpl.java123456789101112131415161718192021222324252627282930313233343536private boolean performKeyboardGroupNavigation(int direction) { // 1. 通过findFocus方法找到当前具有焦点的View，如果当前没有View获取焦点则返回null // 产生一个默认的焦点 final View focused = mView.findFocus(); if (focused == null &amp;&amp; mView.restoreDefaultFocus()) { return true; } // 2. 寻找需要接受焦点的View View cluster = focused == null ? keyboardNavigationClusterSearch(null, direction) : focused.keyboardNavigationClusterSearch(null, direction); // Since requestFocus only takes &quot;real&quot; focus directions (and therefore also // restoreFocusInCluster), convert forward/backward focus into FOCUS_DOWN. int realDirection = direction; if (direction == View.FOCUS_FORWARD || direction == View.FOCUS_BACKWARD) { realDirection = View.FOCUS_DOWN; } // 3. 通过调用restoreFocusNotInCluster restoreFocusInCluster切换焦点 if (cluster != null &amp;&amp; cluster.isRootNamespace()) { // the default cluster. Try to find a non-clustered view to focus. if (cluster.restoreFocusNotInCluster()) { playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction)); return true; } // otherwise skip to next actual cluster cluster = keyboardNavigationClusterSearch(null, direction); } if (cluster != null &amp;&amp; cluster.restoreFocusInCluster(realDirection)) { // 播发按键音 playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction)); return true; } return false;} 首先调用了View.findFocus方法开始查找焦点View。 View.java123public View findFocus() { return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0 ? this : null;} ViewGroup.java12345678910public View findFocus() { if (isFocused()) { return this; } // mFocused是具有焦点的View if (mFocused != null) { return mFocused.findFocus(); } return null;} 在View中，和hasFocus方法一样，是通过判断标识位来判断是否具有焦点。而在ViewGroup，如果自身具有焦点直接返回自己，如果是子View中具有焦点则通过递归调用mFocused.findFocus直到找到焦点View。 当查询到焦点View后通过View.keyboardNavigationClusterSearch或ViewRootImpl.keyboardNavigationClusterSearch进行查找目标焦点View。而View与ViewRootImpl都是会将搜寻工作代理给FocusFinder类，但在View中，会进行判断是否为根View，也就是是否为DecorView。 View.java123456789101112131415161718192021222324252627 public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction) { if (isKeyboardNavigationCluster()) { currentCluster = this; } if (isRootNamespace()) { // Root namespace means we should consider ourselves the top of the // tree for group searching; otherwise we could be group searching // into other tabs. see LocalActivityManager and TabHost for more info. // 如果是根View，则代理给FocusFinder负责进行搜寻工作 return FocusFinder.getInstance().findNextKeyboardNavigationCluster( this, currentCluster, direction); } else if (mParent != null) { // 一层一层向上找根View return mParent.keyboardNavigationClusterSearch(currentCluster, direction); } return null; }//ViewRootImpl public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction) { checkThread(); // 代理到FocusFinder return FocusFinder.getInstance().findNextKeyboardNavigationCluster( mView, currentCluster, direction); } 在确定目标View后，通过调用View.restoreFocusNotInCluster与 View.restoreFocusInCluster切换焦点,内部均是通过调用了requestFocus()实现了焦点的切换 View.java123456789101112131415public boolean restoreFocusInCluster(@FocusRealDirection int direction) { // Prioritize focusableByDefault over algorithmic focus selection. if (restoreDefaultFocus()) { return true; } return requestFocus(direction);}public boolean restoreDefaultFocus() { return requestFocus(View.FOCUS_DOWN);}public boolean restoreFocusNotInCluster() { return requestFocus(View.FOCUS_DOWN);} 通过方向键焦点移动ViewRootImpl.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private boolean performFocusNavigation(KeyEvent event) { int direction = 0; // 1. 根据按键确定方向 switch (event.getKeyCode()) { case KeyEvent.KEYCODE_DPAD_LEFT: if (event.hasNoModifiers()) { direction = View.FOCUS_LEFT; } break; case KeyEvent.KEYCODE_DPAD_RIGHT: if (event.hasNoModifiers()) { direction = View.FOCUS_RIGHT; } break; case KeyEvent.KEYCODE_DPAD_UP: if (event.hasNoModifiers()) { direction = View.FOCUS_UP; } break; case KeyEvent.KEYCODE_DPAD_DOWN: if (event.hasNoModifiers()) { direction = View.FOCUS_DOWN; } break; case KeyEvent.KEYCODE_TAB: if (event.hasNoModifiers()) { direction = View.FOCUS_FORWARD; } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) { direction = View.FOCUS_BACKWARD; } break; } if (direction != 0) { // 2. 找到当前聚焦的View View focused = mView.findFocus(); if (focused != null) { // 3. 寻找需要获取焦点的View View v = focused.focusSearch(direction); if (v != null &amp;&amp; v != focused) { // do the math the get the interesting rect // of previous focused into the coord system of // newly focused view focused.getFocusedRect(mTempRect); if (mView instanceof ViewGroup) { ((ViewGroup) mView).offsetDescendantRectToMyCoords( focused, mTempRect); ((ViewGroup) mView).offsetRectIntoDescendantCoords( v, mTempRect); } // 4. 进行焦点状态的切换 if (v.requestFocus(direction, mTempRect)) { playSoundEffect(SoundEffectConstants .getContantForFocusDirection(direction)); return true; } } // Give the focused view a last chance to handle the dpad key. if (mView.dispatchUnhandledMove(focused, direction)) { return true; } } else { // 当没有焦点时产生默认的焦点 if (mView.restoreDefaultFocus()) { return true; } } } return false;} 首先会通过用户实际按下的按键判断当前需要向哪个方向进行搜寻，然后也是通过调用mView.findFocus()找到当前聚焦的View，与组合键操作不同的是，方向键查找下一个是调用的是View.focusSearch(direction)，不过，这个方法内部也是将具体的搜寻工作代理到了FocusFinder这个类上。 View.java1234567public View focusSearch(@FocusRealDirection int direction) { if (mParent != null) { return mParent.focusSearch(this, direction); } else { return null; }} ViewGroup.java1234567891011public View focusSearch(View focused, int direction) { if (isRootNamespace()) { // root namespace means we should consider ourselves the top of the // tree for focus searching; otherwise we could be focus searching // into other tabs. see LocalActivityManager and TabHost for more info. return FocusFinder.getInstance().findNextFocus(this, focused, direction); } else if (mParent != null) { return mParent.focusSearch(focused, direction); } return null;} FocusFinder查找的具体实现但现在先暂时跳过探究FocusFinder如何找到目标View，先来关注下requestFocus这个方法中是如何进行焦点切换工作的。1问题：为什么当前ViewGourp内找不到适合的焦点View话会找到更高级的ViewGroup里的View（可能在添加备选列表时将所有父View符合的View添加到了列表中） 清除焦点清除焦点的方法当手动调用clearFocus方法或使获焦的 View 被移除(隐藏不可见)的时候，会进行焦点的清除工作。 View.java123456789101112131415161718void setFlags(int flags, int mask) {// .../* Check if the GONE bit has changed */ if ((changed &amp; GONE) != 0) { if (((mViewFlags &amp; VISIBILITY_MASK) == GONE)) { if (hasFocus()) { // 进行清除焦点 clearFocus(); if (mParent instanceof ViewGroup) { ((ViewGroup) mParent).clearFocusedInCluster(); } } clearAccessibilityFocus(); // ... } }} ViewGourp.java12345678protected void removeDetachedView(View child, boolean animate) { // ... if (child == mFocused) { child.clearFocus(); } // ... } View.java12345public void clearFocus() { clearFocusInternal(null, true, true);} 焦点的重分配（矫正焦点）当某个View从Gone转变为Visible，或在一个聚焦的父View中的子View可获焦了，焦点需要重新分配到正确的位置上。 View.java123456789101112131415161718192021222324252627282930313233343536373839void setFlags(int flags, int mask) { final int newVisibility = flags &amp; VISIBILITY_MASK; if (newVisibility == VISIBLE) { if ((changed &amp; VISIBILITY_MASK) != 0) { /* * If this view is becoming visible, invalidate it in case it changed while * it was not visible. Marking it drawn ensures that the invalidation will * go through. */ mPrivateFlags |= PFLAG_DRAWN; invalidate(true); needGlobalAttributesUpdate(true); // a view becoming visible is worth notifying the parent about in case nothing has // focus. Even if this specific view isn't focusable, it may contain something that // is, so let the root view try to give this focus if nothing else does. // 判断是否可需要通知矫正焦点1 shouldNotifyFocusableAvailable = hasSize(); } } if ((changed &amp; ENABLED_MASK) != 0) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED) { // a view becoming enabled should notify the parent as long as the view is also // visible and the parent wasn't already notified by becoming visible during this // setFlags invocation. // 判断是否可需要通知矫正焦点2 shouldNotifyFocusableAvailable = canTakeFocus(); } else { if (isFocused()) clearFocus(); } } if (shouldNotifyFocusableAvailable &amp;&amp; mParent != null) { // 通知父View需要进行焦点重分配，最终会被ViewRootImpl接收 mParent.focusableViewAvailable(this); }} ViewGroup.java1234567891011121314151617181920public void focusableViewAvailable(View v) { if (mParent != null // shortcut: don't report a new focusable view if we block our descendants from // getting focus or if we're not visible &amp;&amp; (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) &amp;&amp; ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &amp;&amp; (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen()) // shortcut: don't report a new focusable view if we already are focused // (and we don't prefer our descendants) // // note: knowing that mFocused is non-null is not a good enough reason // to break the traversal since in that case we'd actually have to find // the focused view and make sure it wasn't FOCUS_AFTER_DESCENDANTS and // an ancestor of v; this will get checked for at ViewAncestor &amp;&amp; !(isFocused() &amp;&amp; getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) { // 一层一层向上传递 mParent.focusableViewAvailable(v); }} 在一层一层向上传递后，最终会传递到ViewRootImpl中进行具体焦点的分配工作。 ViewRootImpl.java123456789101112131415161718192021222324252627public void focusableViewAvailable(View v) { checkThread(); if (mView != null) { if (!mView.hasFocus()) { // 如果视图树中没有一个View有焦点，则直接在传递来的View上获取焦点 if (sAlwaysAssignFocus || !mAttachInfo.mInTouchMode) { v.requestFocus(); } } else { // the one case where will transfer focus away from the current one // is if the current view is a view group that prefers to give focus // to its children first AND the view is a descendant of it. // 如果当前有焦点View View focused = mView.findFocus(); // 检查是否需要将焦点转移到这个View上 if (focused instanceof ViewGroup) { ViewGroup group = (ViewGroup) focused; // 如果当前焦点View是传递来的View的直接父View， // 并且焦点优先子获取View，则将焦点传递给v if (group.getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS &amp;&amp; isViewDescendantOf(v, focused)) { v.requestFocus(); } } } }} 所以转移规则为： 如果当前视图树中不存在焦点，则直接尝试将焦点分发给这个可获焦的 View 如果存在焦点，则检查焦点View为直系父View，并配置了FOCUS_AFTER_DESCENDANTS,是否需要将焦点转移到这个可获焦的 View 参考文章 [1] Android焦点分发过程解析 - 薛定谔的程序猫 [2] Android焦点搜索过程解析 - 薛定谔的程序猫","link":"/2021/03/31/Android%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/tags/JavaWeb/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"View体系","slug":"Android/View体系","link":"/categories/Android/View%E4%BD%93%E7%B3%BB/"},{"name":"BUG总结","slug":"Android/BUG总结","link":"/categories/Android/BUG%E6%80%BB%E7%BB%93/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/categories/JavaWeb/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"Gradle","slug":"Android/Gradle","link":"/categories/Android/Gradle/"}]}