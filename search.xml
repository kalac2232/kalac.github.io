<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android事件分发分析</title>
      <link href="/2022/08/16/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%88%86%E6%9E%90/"/>
      <url>/2022/08/16/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>本篇所分析的源码为Android 28，可能与其他版本有所出入</div></article><h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><ol><li>输入事件由FrameWork层发送到<code>ViewRootImpl</code>的内部类<code>WindowInputEventReceiver</code>上，根据<code>InputEvent</code>的类型，进行不同的分发方式。</li><li>如果是<code>TouchEvent</code>，<code>ViewRootImpl</code>调用其保存的<code>View.dispatchTouchEvent()</code>方法，这个<code>View</code>一般是<code>DecorView</code>，如果是悬浮窗一类的直接是<code>WindowManagerGlobal.addView()</code>的那个<code>View</code></li><li><code>DecorView</code>首先将该事件交由<code>Window</code>中的<code>callback</code>进行处理，也就是<code>Activity</code>或<code>Dialog</code></li><li><code>Activity</code>然后在交由<code>Window</code>也就是<code>PhoneWindow</code>处理</li><li><code>PhoneWindow</code>在交由内部保存的<code>DecorView</code>进行处理</li><li><code>DecorView</code>使用<code>ViewGroup</code>分发逻辑向下分发。</li><li><code>ViewGroup</code>首先判断自身是否拦截事件，如果<code>onInterceptTouchEvent</code>返回<code>true</code>，则自身消费事件。</li><li>如果不拦截，则将子<code>View</code>按z-order的顺序排序，根据<code>MotionEvent</code>的x、y寻找子<code>View</code>，将事件分发给它们。</li><li>如果子<code>View</code>是<code>ViewGroup</code>，则同样继续分发给子<code>View</code>，</li><li>如果子<code>View</code>是<code>View</code>，那么通过判断<code>mOnTouchListener</code>或<code>onTouchEvent</code>的返回值看是否事件消费</li><li>如果所有的子<code>View</code>都没有消费这个事件，则事件向上返回，由父<code>ViewGroup</code>决定自身是否消费。</li><li>最终<code>Activity</code>、<code>Window</code>都不消费，则<code>ViewRootImpl</code>调用<code>finishInputEvent</code>结束本次事件。</li></ol><span id="more"></span><h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><p>事件由底层传入到<code>InputManagerService</code>，再转由<code>WindowManagerServer</code>发送到<code>InputEventReceiver</code>类的<code>dispatchInputEvent()</code>方法中，详细解析见 <a href="https://www.jianshu.com/p/f984523efd3c">Android Input事件获取与分发简单总结</a>。</p><figure class="highlight java"><figcaption><span>InputEventReceiver.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event, displayId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个方法需要子类进行重写，否则则直接结束了事件分发。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    finishInputEvent(event, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>InputEventReceiver</code>是一个抽象类，具体子类实现在<code>ViewRootImpl</code>中。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重写了父类方法，处理Input事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ViewRootImpl.setView()</code>方法中会创建<code>InputChannel</code>和<code>WindowInputEventReceiver</code>实例，<code>InputChannel</code>连通了<code>WindowManagerServer</code>与App进程的事件输入通道。</p><blockquote><p> <code>ViewRootImpl.setView</code>会在<code>Activity</code>、<code>Dialog</code>或直接调用<code>WindowManagerGlobal.addView()</code>方法时调用。具体可详见<a href="#">Post not found: App启动流程</a>。</p></blockquote><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向WindowManagerServer注册时传入mInputChannel</span></span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">                mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例化Receiver</span></span><br><span class="line">        mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                Looper.myLooper()); <span class="comment">// 传入了InputChannel和主线程的Looper</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个<code>InputEvent</code>输入后，便调用到了<code>ViewRootImpl.enqueueInputEvent()</code>中开始了处理分发过程</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    adjustInputEventForCompatibility(event);</span><br><span class="line">    <span class="comment">// 将InputEvent封装为QueuedInputEvent，优先从缓存池中复用对象。</span></span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always enqueue the input event in order, regardless of its time stamp.</span></span><br><span class="line">    <span class="comment">// We do this because the application or the IME may inject key events</span></span><br><span class="line">    <span class="comment">// in response to touch events and we want to ensure that the injected keys</span></span><br><span class="line">    <span class="comment">// are processed in the order they were received and we cannot trust that</span></span><br><span class="line">    <span class="comment">// the time stamp of injected events are monotonic.</span></span><br><span class="line">    <span class="comment">// 将新事件加入到未处理事件链中</span></span><br><span class="line">    QueuedInputEvent last = mPendingInputEventTail;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingInputEventHead = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.mNext = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingInputEventCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        doProcessInputEvents();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>doProcessInputEvents()</code> -&gt; <code>deliverInputEvent()</code>-&gt;最后到达<code>ViewPostImeInputStage.onProcess()</code>方法中。</p><p><code>ViewPostImeInputStage</code>是一个责任链模式中的一环，在事件处理责任链中完整的责任链为：<code>mSyntheticInputStage</code> -&gt; <code>viewPostImeStage</code> -&gt; <code>nativePostImeStage</code> –&gt;<code> earlyPostImeStag</code>e –&gt;<code> imeStage</code> –&gt; <code>viewPreImeStage</code> –&gt; <code>viewPreImeStage</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------- InputStage的子类 ----------------------------</span></span><br><span class="line"><span class="comment">// 将预先输入事件提供给视图层次结构。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPreImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 执行事后输入事件的早期处理。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EarlyPostImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将后期输入事件提供给视图层次结构。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPostImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 从未处理的输入事件执行新输入事件的合成。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 用于实现支持输入事件的异步和无序处理的输入流水线级的基类。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// ----------------- AsyncInputStage的子类----------------------------</span></span><br><span class="line"><span class="comment">// 将预先输入事件提供给 NativeActivity。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NativePreImeInputStage</span> <span class="keyword">extends</span> <span class="title">AsyncInputStage</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">InputQueue</span>.<span class="title">FinishedInputEventCallback</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将预先输入事件提供给视图层次结构。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImeInputStage</span> <span class="keyword">extends</span> <span class="title">AsyncInputStage</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">InputMethodManager</span>.<span class="title">FinishedInputEventCallback</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将事后输入事件提交到 NativeActivity</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NativePostImeInputStage</span> <span class="keyword">extends</span> <span class="title">AsyncInputStage</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">InputQueue</span>.<span class="title">FinishedInputEventCallback</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>责任链在<code>ViewRootImpl.setView()</code>中进行拼接。</p><p>在<code>ViewPostImeInputStag</code>e中，对<code>InputEvent</code>事件进行了区分，如果是按键事件则走按键的分发逻辑，具体解析见<a href="/2021/03/31/Android%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/" title="Android焦点机制">Android焦点机制</a>中。而触摸点按事件则首先调用了<code>mView.dispatchPointerEvent()</code>方法。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPostImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">            <span class="comment">// 分发按键事件</span></span><br><span class="line">            <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">            <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 分发触摸事件</span></span><br><span class="line">                <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 分发轨迹球事件</span></span><br><span class="line">                <span class="keyword">return</span> processTrackballEvent(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> processGenericMotionEvent(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 交由ViewRootImpl中的View开发分发点击事件</span></span><br><span class="line">        <span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，则开始了事件分发逻辑。</p><h3 id="ViewRootImpl分发逻辑"><a href="#ViewRootImpl分发逻辑" class="headerlink" title="ViewRootImpl分发逻辑"></a>ViewRootImpl分发逻辑</h3><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="comment">// 在View中开始分发</span></span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是普通<code>View</code>，则直接开始了事件分发流程，但如果是<code>DecorView</code>，因其重写了<code>dispatchTouchEvent()</code>方法，会将事件首先交由<code>Window</code>的<code>callback</code>处理</p><figure class="highlight java"><figcaption><span>DecorView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">            ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);<span class="comment">// 分发到callback上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>Window</code>的<code>callback</code>则是在创建<code>PhoneWindow</code>时传入的，即是<code>Activity</code>或<code>Dialog</code>实例。</p><p>此处拿<code>Activity</code>进行分析。<code>Activity</code>将<code>MotionEvent</code>事件又转交由<code>Window</code>进行处理。</p><figure class="highlight java"><figcaption><span>Activity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// 可供子类做一些事情</span></span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交由window处理分发事件</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果window分发过后并没有消费事件，则activity自身则尝试处理事件。</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Window</code>将<code>MotionEvent</code>事件通过调用<code>DecorView.superDispatchTouchEvent()</code>方法转交<code>DecorView</code>进行处理</p><figure class="highlight java"><figcaption><span>PhoneWindow.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交由DecorView</span></span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DecorView</code>中则调用父类的<code>dispatchTouchEvent()</code>方法进行分发，而<code>DecorView</code>是<code>FrameLayout</code>的子类，则分发防止遵循<code>ViewGroup</code>的分发逻辑</p><figure class="highlight java"><figcaption><span>DecorView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了ViewGroup.dispatchTouchEvent</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>MotionEvent</code>事件则沿着<code>ViewRootImpl</code>-&gt;<code>DecorView</code>-&gt;<code>Activity</code>-&gt;<code>Window</code>-&gt;<code>DecorView</code>-&gt;<code>ViewGroup</code>-&gt;<code>View</code>的顺序分发。这样设计可以保证逻辑上的大容器先接受事件，小容器后接受事件，大容器可以直接将touch事件进行拦截不分发。而如果<code>Window</code>中直接添加了<code>View</code>的话，例如常见的悬浮窗，那么事件传递则为<code>ViewRootImpl</code>-&gt;<code>ViewGroup</code>-&gt;<code>View</code>。</p><h3 id="ViewGroup的分发逻辑"><a href="#ViewGroup的分发逻辑" class="headerlink" title="ViewGroup的分发逻辑"></a>ViewGroup的分发逻辑</h3><p>每个MotionEvent存储了<strong>当前这个手指</strong>事件的索引，以及多指情况下其他<strong>全部手指</strong>的触摸点坐标集合，高8位存储触摸点索引，低8位是存储Action类型。多指操作时，除第一个手指触发的是<code>ACTION_DOWN</code>，其余都会触发<code>ACTION_POINTER_DOWN</code>。分发时，先判断是否是事件的开始<code>ACTION_DOWN</code>事件或已经子<code>View</code>已消费<code>ACTION_DOWN</code>事件，然后自身是否拦截，如果已有目标子<code>View</code>，则直接分发给目标<code>View</code>，否则，寻找触摸坐标对应的<code>View</code>，判断其是否进行消费。如果最终没有子<code>View</code>消费，则判断自身是否消费。</p><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="comment">// action的高9-16位表示索引值</span></span><br><span class="line">        <span class="comment">// 低1-8位表示事件类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="comment">// 取出事件类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle an initial down.一次新的点击事件，则重制View状态</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">// 如果是事件的开始或之前向下分发过事件，则判断自身是否拦截事件</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 子View可以通过requestDisallowInterceptTouchEvent更改flag使得父控件始终不拦截事件</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">// 判断自身是否拦截</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for cancelation. 判断事件是否是Cancel</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// 判断是否是多指情况下需要分割索引</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有Down事件才去寻找子View，其他事件直接在TouchTarget链中寻找View分发</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 获取当前的event事件所对应的索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="comment">// 找出对应的触摸点id值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                <span class="comment">// down事件表示该触控点事件序列是一个新的序列</span></span><br><span class="line">                <span class="comment">// 清除之前绑定到到该触控id的TouchTarget</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="comment">// View中可以配置z属性导致children数组中的顺序并不是实际的从前到后</span></span><br><span class="line">                    <span class="comment">// 根据z轴将子View从前到后排序成List</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="comment">// 依次取出View</span></span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断Child的可见性和动画状态是否能接受事件</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                            <span class="comment">// 判断这个点是否在View中</span></span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">// 如果View不符合条件直接跳出本次循环，找下一个View</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">// 如果这个View已经在TouchTarget链中，则更新新的触控点id</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 将事件发送给这个child，如果是多点则根据id拆分Event</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 加入到链中</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// 没有子View想消费事件，则自己判读是否消费</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 分发事件</span></span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="comment">// 如果是Down事件，可能已经被消费</span></span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            <span class="comment">// 如果是Up事件，则根据id将View移出链</span></span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定分发的<code>View</code>后，通过调用<code>dispatchTransformedTouchEvent()</code>方法进行分发。如果是多指情况，则会通过id将拆分重组新的<code>MotionEvent</code></p><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="comment">// 获取存放全部的点id的int</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="comment">// 取出desired的那一位的点id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="comment">// 如果全部的点信息中与desired的那一位的点id不同，则丢弃该事件</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don&#x27;t need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="comment">// 如果全部点信息与目标点信息相同，说明当前只有一个点触摸</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则则拆分Event，从全部触摸事件集合中单独取出对应id的事件并组装成Event</span></span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有目标child，则分发给自己</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="View分发逻辑"><a href="#View分发逻辑" class="headerlink" title="View分发逻辑"></a>View分发逻辑</h3><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取action类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="comment">// 如果是down事件，停止正在的滚动</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="comment">// 先判断mOnTouchListener是否消费</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果mOnTouchListener不消费的话则判断onTouchEvent是否消费</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">    <span class="comment">// of the gesture.</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/f984523efd3c">Android Input事件获取与分发简单总结</a></p><p><a href="https://juejin.cn/post/6920883974952714247">Android事件分发机制二：核心分发逻辑源码解析</a></p><p><a href="https://www.jianshu.com/p/b7f33f46d33c">View·InputEvent事件投递源码分析（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler机制</title>
      <link href="/2022/08/12/Handler/"/>
      <url>/2022/08/12/Handler/</url>
      
        <content type="html"><![CDATA[<article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>本篇所分析的源码为Android 28</div></article><p><code>Handler</code>经常被用于<strong>异步消息通知</strong>与<strong>延时任务处理</strong>。</p><p>在子线程中处理数据后，此时需要在UI线程回显数据，在主线程创建<code>Handler</code>对象后，子线程通过<code>Handler.sendMessage()</code>方法发送到<code>handler</code>的处理队列中，在<code>handleMessage()</code>方法中做相应的处理。</p><p>延时任务通过<code>postDelayed()</code>方法，一定时间后执行传入的<code>Runnable</code>对象。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Handler</code>中的关键类为<code>Looper</code>,其提供了一个<code>MessageQueue</code>消息队列，无论是将要发送的<code>message</code>还是执行的<code>runnable</code>都会被封装为<code>Meassage</code>类压入消息队列中，<code>Looper</code>中通过<code>loop()</code>方法中的死循环，根据压入的时间或延时时间，顺序分发队列中的消息。</p><span id="more"></span><h4 id="构建Handler"><a href="#构建Handler" class="headerlink" title="构建Handler"></a>构建Handler</h4><figure class="highlight java"><figcaption><span>Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper(); <span class="comment">// 获取当前线程中的Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue; <span class="comment">// 获取到Looper中的队列引用</span></span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async; <span class="comment">// 是否异步处理消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Looper和MessageQueue"><a href="#创建Looper和MessageQueue" class="headerlink" title="创建Looper和MessageQueue"></a>创建Looper和MessageQueue</h4><p><code>Looper</code>对象创建后会保存到当前线程的<code>ThreadLocal</code>中，而主线程<code>ActivityThread</code>在启动时，便创建了本线程的<code>Looper</code>对象。</p><figure class="highlight java"><figcaption><span>ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">// 创建主线程Looper</span></span><br><span class="line">    ...</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop(); <span class="comment">// 开始死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">// 创建Looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();<span class="comment">// 将当前的looper对象记录为主线程的Looper</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed)); <span class="comment">// 将新创建Looper设置到ThreadLocal中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>Looper</code>中的<code>MessageQueue</code>，则在<code>Looper</code>的构造方法中一并创建。</p><figure class="highlight java"><figcaption><span>Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed); <span class="comment">// 创建消息队列</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述步骤，主线程的<code>Handler</code>即可工作起来，而如果想要在子线程中使用<code>Handler</code>，则需要手动创建<code>Looper</code>，并开启循环。或者直接使用主线程的<code>looper</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;   </span><br><span class="line">   <span class="meta">@Override</span>    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">       Looper.prepare();  <span class="comment">//创建当前线程的Looper</span></span><br><span class="line">       Handler handler = <span class="keyword">new</span> Handler() &#123;           </span><br><span class="line">           <span class="meta">@Override</span>          </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;                </span><br><span class="line">               <span class="comment">// ...          </span></span><br><span class="line">           &#125;        </span><br><span class="line">       &#125;;        </span><br><span class="line">       handler.sendEmptyMessage(<span class="number">0</span>);   </span><br><span class="line">       Looper.loop();  <span class="comment">//looper开始处理消息。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h4 id="MessageQueue压入消息"><a href="#MessageQueue压入消息" class="headerlink" title="MessageQueue压入消息"></a>MessageQueue压入消息</h4><p>如果是通过<code>post()</code>方法传入了一个<code>Runnale</code>，在<code>handler</code>中会通过<code>getPostMessage()</code>方法封装为<code>message</code>对象。</p><figure class="highlight java"><figcaption><span>Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis); <span class="comment">// 封装为Message对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r; <span class="comment">// 将Runnable设置为Message的callback参数</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通过<code>sendMessage()</code>发出的消息，最终与<code>postDelayed()</code>一样，都会调用到<code>sendMessageDelayed()</code>，最终调用到<code>enqueueMessage()</code>方法。</p><figure class="highlight java"><figcaption><span>Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">// 将Handler自身的引用设置到msg上，当msg的处理时间到后，会分发到该Handler中处理</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;<span class="comment">// 如果该Handler是异步的，</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>); <span class="comment">// 则将该Handler发送的消息设置为异步消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">// 压入消息队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过调用<code>queue.enqueueMessage()</code>将消息加入到队列中。</p><p>在<code>MessageQueue</code>中，消息存放是一个链表，<code>mMessages</code>字段为链表头，方法中传入的<code>when</code>字段为该<code>message</code>预期执行的时间，通过遍历列表，通过判断链表中已有的消息的时间，使插入新消息后，链表中的消息时间顺序由小到大。</p><figure class="highlight java"><figcaption><span>MessageQueue.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;<span class="comment">// 头指针</span></span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123; </span><br><span class="line">            <span class="comment">// 如果头指针为空，或第一个消息的执行时间都晚于新消息，则新消息成为头指针</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 逐步向后遍历</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123; <span class="comment">// 找到尾节点或执行时间晚于新消息的节点，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// 加入到列表中</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">            <span class="comment">// 如果之前没有任务处理，进入了无限阻塞状态，则压入消息后需要唤醒线程</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loop处理消息"><a href="#loop处理消息" class="headerlink" title="loop处理消息"></a>loop处理消息</h4><p>当<code>Looper</code>创建后，需要调用<code>loop()</code>方法进入死循环模式，当<code>MessageQueue</code>中出现了新消息，则唤醒线程，推出一个消息，交由<code>Looper</code>处理。</p><figure class="highlight java"><figcaption><span>Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123; <span class="comment">// 检测线程中是否存在Looper对象</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 进入死循环</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block，当存在消息后会唤醒线程，推出Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg); <span class="comment">// 交由send该Message的Handler处理</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked(); <span class="comment">// 对 Message 进行了回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出<code>Message</code>后，交由<code>Message</code>中的<code>target</code>对象处理，而这个<code>target</code>对象则就是在<code>Handler.enqueueMessage()</code>的方法中赋值的。</p><p><code>Handler</code>中处理这个<code>Message</code>。</p><figure class="highlight java"><figcaption><span>Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123; <span class="comment">// 如果是Runnable</span></span><br><span class="line">        handleCallback(msg); <span class="comment">//  则直接run。 (message.callback.run();)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是正常的消息，则调用handleMessage方法处理。</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 回调到构造Handler时传入的callback中</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认为空实现，如果有子类实现，则可以重写该方法处理消息。</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MessageQueue推出Message机制"><a href="#MessageQueue推出Message机制" class="headerlink" title="MessageQueue推出Message机制"></a>MessageQueue推出Message机制</h4><figure class="highlight java"><figcaption><span>MessageQueue.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程休眠nextPollTimeoutMillis时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">// 如果是msg.target==null则说明遇到了一个同步屏障，会优先取出异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">// 无视链表中同步消息，直接遍历下一个异步消息。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理链表头的消息或取出的异步消息，</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当下一个消息的处理时间还没到达，则计算时间差值，当下次运行至nativePollOnce，阻塞相应的时间。</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.取出消息</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;<span class="comment">// 无消息，则会一直堵塞,等待调用nativeWake唤醒</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">// 如果当前没有了IdleHandler，更改阻塞标志位，在下一次循环后正式进入阻塞状态</span></span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用回调</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 移除已回调的监听</span></span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IdleHandlers</code>：可以在通过<code>addIdleHandler()</code>方法添加监听，如果链表中没有消息后，在休眠前调用该监听，处理一些消息，<code>MessageQueue</code>在调用完回调后，会移除监听，在下次循环后进入阻塞状态。</p><p>同步屏障是一个<code>target == null</code>的<code>message</code>，作用是作为一个标志，当链头为该标志时跳过同步消息，快速处理链表中的异步消息。为了更快地响应UI刷新事件，在<code>ViewRootImpl</code>的<code>scheduleTraversals</code>函数中就用到了同步屏障。</p><figure class="highlight java"><figcaption><span>MessageQueue.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain(); <span class="comment">// 获取一个Message对象</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<span class="comment">// 根据时间顺序寻找插入位置，因为when一般为当前时间，往往会插入到链表头</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主线程不卡顿的问题"><a href="#主线程不卡顿的问题" class="headerlink" title="主线程不卡顿的问题"></a>主线程不卡顿的问题</h5><p><code>MessageQueue</code>中通过Linux的<code>epoll</code>机制，阻塞、唤醒主线程。</p><p>通过<code>epoll_create()</code>初始化，注册监控几个文件描述符，当调用<code>epoll_wait()</code>后，会进入阻塞状态，等待 IO 事件。当某个描述符就绪(读或写就绪)，使得 epoll 被唤醒。若超过了设定的超时时间，同样也会被唤醒避免一直阻塞。而java层调用<code>nativeWake</code>时，对描述符写入1，引发更改，唤醒线程。</p><p>而在主线程阻塞时，会释放CPU资源进入休眠状态，不会消耗大量CPU资源。而当绘制消息加入消息队列后，线程唤醒，处理UI绘制，绘制后再次进入阻塞状态，并不会引发UI卡顿。而绘制消息则是由两个binder线程<code>ApplicationThread</code>和<code>ActivityManagerProxy</code>发出。</p><h5 id="Handler泄露的原因及正确写法"><a href="#Handler泄露的原因及正确写法" class="headerlink" title="Handler泄露的原因及正确写法"></a>Handler泄露的原因及正确写法</h5><p>在<code>Activity</code>中直接创建<code>Handler</code>后，因为内部类默认持有一个外部类的引用，而通过<code>Handler</code>发出的<code>Message</code>中又会设置<code>Handler</code>的引用。当这个<code>Message</code>是一个延时消息后，在队列中等待中时，当<code>Activity</code>关闭，因为<code>message</code>还持有<code>Activity</code>的引用，导致<code>Acitity</code>无法销毁，内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123; <span class="comment">// 静态类</span></span><br><span class="line">    <span class="comment">//创建一个弱引用持有外部类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyHandler</span><span class="params">(MainActivity content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        MainActivity activity= content.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h5><p>通过继承<code>Thread</code>类，在调用<code>run</code>方法时直接创建了<code>Looper</code>对象，<strong>快速地创建1个带有<code>Looper</code>对象的新工作线程</strong>。</p><figure class="highlight java"><figcaption><span>HandlerThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val handlerThread = HandlerThread(<span class="string">&quot;handlerThread&quot;</span>)</span><br><span class="line">handlerThread.start()</span><br><span class="line">handler = object : Handler(handlerThread.looper) &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">handleMessage</span><span class="params">(msg: Message?)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>在<code>ActivityThread</code>启动时，创建了主线程的<code>Looper</code>对象，将<code>looper</code>对象存放到<code>ThreadLocal</code>中，并调用了<code>loop()</code>方法进入无限循环等待消息。</li><li>在创建<code>Looper</code>对象时，一并创建了<code>MessageQueue</code>对象，并在底层注册了文件操作符的监听。</li><li>在创建<code>Handler</code>时，构造方法中取出当前线程<code>ThreadLocal</code>存放的<code>Looper</code>对象，如果是子线程并未提前创建<code>Looper</code>对象，则抛出异常。也可以通过控制<code>async</code>参数，使得<code>Handler</code>发送的消息为异步消息（优先处理需设置同步屏障）。</li><li>无论是发送<code>Message</code>还是<code>Runnale</code>，最终都会封装为<code>Message</code>类，然后将当前时间加上延时时间计算出执行时间，交由<code>MessageQueue</code>加入链表。</li><li><code>MessageQueue</code>按时间顺序把消息加入到链表中，如果之前链表为空，则唤醒线程。</li><li><code>MessageQueue</code>中如果没有消息，则一直处于无限阻塞状态，当有消息插入被唤醒，则开始判断链头的消息是不是同步屏障的标识<code>（target==null）</code>，如果是，则一直寻找下一个异步消息，找到后推出消息到<code>Looper</code>处理，直到处理完异步消息，移除同步屏障。如在处理消息时，消息的执行时间未到，则通过<code>nativePollOnce()</code>方法将线程休眠时间差值。链表中消息完全处理完成后，则进入无限阻塞状态。</li><li><code>Looper</code>中从<code>MessageQueue</code>取出消息后，交由<code>Message</code>中的<code>target</code>对象消费消息，<code>target</code>就是发送该<code>Message</code>的<code>Handler</code>。</li><li>最终分发到<code>Handler</code>的<code>handleMessage()</code>方法中。</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s/Ylc5mPwMzWoK2CIthZy0Vw">同步屏障？阻塞唤醒？和我一起重读 Handler 源码</a></p><p><a href="https://www.zhihu.com/question/34652589/answer/90344494">Android中为什么主线程不会因为Looper.loop()里的死循环卡死</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解CA证书</title>
      <link href="/2022/07/19/ca%E8%AF%81%E4%B9%A6/"/>
      <url>/2022/07/19/ca%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>由于http协议的不安全性，在传输敏感数据时需要对数据进行加密处理。如果采用对称加密，使用相同的密钥对数据进行加密，密钥的保存又是一个问题。如果放到前端中存放，无论如何防护，都有被破解泄漏的可能性，而一旦泄漏，前端则需要升级新版本才能更新密钥，还需对于未升级的老版本做兼容性处理。</p><p>如果采用非对称加密，客户端每次去请求这次通信的公钥，后续的通讯内容通过这个公钥进行加密发送到服务端，服务端用自己的私钥进行解密获取内容。响应内容也通过私钥加密发送到客户端，客户端用公钥解密。</p><p>该方案不会在客户端中存放密钥，降低了密钥泄漏的风险，但非对称加密的性能损耗较高，所以整个通信过程中会先通过非对称加密和服务器交换一个密钥。后续通过该密钥进行对称加密通信。</p><p>但是非对称加密通信通过中间人攻击即可完全获取通信内容。</p><p><img src="/images/image-20220719161149012.png" alt="image-20220719161149012"></p><p>中间人通过截获客户端的请求，模拟新的请求向服务器请求公钥，获取到真实的公钥后，自身生成新的公钥-私钥对，将自身的公钥发送给客户端，由此通过自身的私钥解析客户端发送的内容，并将内容用真实的公钥加密后发送给服务端，并用公钥解析出服务端返回的内容。</p><p>为了验证服务器的身份，防止中间人攻击，CA证书由此诞生。通过一个信任的三方机构去验证服务端的可靠性。</p><span id="more"></span><h3 id="什么是CA证书"><a href="#什么是CA证书" class="headerlink" title="什么是CA证书"></a>什么是CA证书</h3><p>CA证书是由公认权威的第三方机构颁发的，申请者将自己的身份信息、公钥提交到签发机构后，机构核实身份后生成对应的证书颁发给申请人。</p><p>证书中除了包含了申请人提交的信息，并且还包含了一些CA机构的信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、证书所采用的加密算法、有效时间、证书序列号等信息的明文，同时包含一个由明文信息加密生成的签名；</p><p>服务端拥有了证书后，当客户端发起请求时，服务端首先会将证书发送给客户端，客户端去验证证书的合法性，通过后则可以取出证书的服务端的公钥进行后续的通讯。</p><h4 id="证书的签发过程"><a href="#证书的签发过程" class="headerlink" title="证书的签发过程"></a>证书的签发过程</h4><ol><li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p></li><li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p></li><li><p>最后将 Certificate Signature 添加在文件证书上，形成最后的数字证书；</p></li></ol><h4 id="证书的认证过程"><a href="#证书的认证过程" class="headerlink" title="证书的认证过程"></a>证书的认证过程</h4><ol start="2"><li>客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>然后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li><li>客户端向CA发送OCSP请求验证证书的有效期、是否被吊销（或由服务端代为发送请求查询）</li></ol><h5 id="OCSP装订"><a href="#OCSP装订" class="headerlink" title="OCSP装订"></a><strong>OCSP装订</strong></h5><p>OCSP装订（英语：OCSP Stapling），正式名称为TLS证书状态查询扩展，可代替在线证书状态协议（OCSP）来查询X.509证书的状态。服务器在TLS握手时发送事先缓存的OCSP响应，用户只需验证该响应的有效性而不用再向数字证书认证机构（CA）发送请求。</p><p>OCSP装订解决了在线证书协议中的大多数问题。CA给网站颁发证书之后，网站的每个访问者都会进行OCSP查询。因此使用在线证书协议时，高并发的请求会给CA的服务器带来很大的压力。同时由于必须和CA建立连接，OCSP查询还会影响浏览器打开页面的速度并泄漏用户隐私。此外，当OCSP查询无法得到响应时，浏览器必须选择是否在无法确认证书状态的情况下继续连接，造成安全性和可用性二选一的困局。</p><h3 id="认证链"><a href="#认证链" class="headerlink" title="认证链"></a>认证链</h3><p>实际使用过程中，服务器证书的签发工作不是由根证书直接完成，而是可能由二级或更深层级的证书进行签发。这些证书也可称为中间证书。中间证书依次认证，最终都是由根证书认证。</p><p><img src="/images/image-20220720140829584.png" alt="image-20220720140829584"></p><p>在认证过程中，只是多了几次认证过程，只要最后能找到一个操作系统信任的证书所认证的证书，则说明该认证链可靠。</p><p>认证链存在的优势：</p><ol><li>减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;</li><li>根证书一般内置在客户端（浏览器或操作系统）中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救。中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;</li></ol><h3 id="交叉认证"><a href="#交叉认证" class="headerlink" title="交叉认证"></a>交叉认证</h3><p>一个CA机构将自己的证书交由其他CA机构进行签名认证的过程叫做交叉认证，生成的证书为交叉证书。使用交叉证书认证颁发的证书可以通过两个CA的认证。</p><p>CA机构在更换根证书时期会使用这种方式，在新的根证书还未完全布置到操作系统中时，暂时使用其他的CA机构进行认证。当部署完成后，后续的新证书颁发都使用自己的根证书认证的证书进行签名。</p><h3 id="不同级别的CA证书"><a href="#不同级别的CA证书" class="headerlink" title="不同级别的CA证书"></a>不同级别的CA证书</h3><ul><li><p>DV</p><p>最基础的SSL证书类别：DV（Domain Validaion） SSL证书，俗称“域名验证型SSL证书”。这种 SSL证书只具备最基本的 HTTPS 加密作用。不涉及到SSL证书的使用方身份验证，因此具有颁发快，成本低的优点。这种证书满足了大量的个人站长对 https 的加密需求。同时也是各个小微企业从节约经营成本的角度出发可以选择的SSL证书类型。</p></li><li><p>DV</p><p>普通的组织验证证书：OV（Organization Validation） SSL证书。俗称“组织验证型SSL证书”或者“企业性SSL证书”。这类证书从加密和身份认证两方面对网站进行了一个提高。申请这类证书需要具有组织身份，例如公司、政府、学校、医院等各类单位组织。证书签发机构在签发证书之前，会对这个组织身份的真实性进行验证，确保组织的真实存在以及确认该组织本身确实是在申请SSL证书，防止冒名顶替。这种 OV SSL证书的字段里面包含了使用证书的单位名称。</p></li><li><p>OV</p><p>扩展验证类SSL证书：EV （Extended Validation）SSL证书。这类SSL证书俗称“增强型SSL证书”或者“扩展验证型SSL证书”。这种SSL证书对申请者身份做了更加严格的审核，也正因如此，很多浏览器对装有 EV SSL证书的网站进行了特别的标注：例如在浏览器地址栏直接显示单位名称，或者在浏览器地址栏点击小锁标志后显示单位名称</p></li></ul><h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>SSL证书并不一定非要权威的CA机构去签发，自己也可以用自己的私钥去签发一个证书，这种证书就是自签名证书。因为自签名证书并没有通过CA机构认证，也没有内置于操作系统中，所以在浏览器访问过程中会收到“不安全”警告。</p><p>自签名证书的优势：</p><ul><li>免费，每个人都可以通过Openssl生成证书，在一定的使用场景中可以减少预算。</li><li>随时签发，不需要等待三分机构审核资质。</li></ul><p>缺点：</p><ul><li><strong>不受浏览器信任</strong>。</li><li>吊销难。</li><li>易被伪装，在浏览器环境无法防范中间人攻击，也就失去了证书的意义。</li></ul><p>自签名证书也可以用于中间人攻击，自行生成一个与受害者公开信息完全相同的证书进行攻击。</p><h3 id="HTTPS的中间人攻击"><a href="#HTTPS的中间人攻击" class="headerlink" title="HTTPS的中间人攻击"></a>HTTPS的中间人攻击</h3><p>严格意义上HTTPS并不存在中间人攻击，但部分应用开发者忽视证书的校验，或者对非法证书处理不当，导致依旧可以进行攻击。</p><p>攻击方式：</p><ol><li>在操作系统中也安装中间人的根证书，</li><li>将请求代理转发到拥有被认证过CA认证过的服务器上转发请求。</li></ol><p>上述攻击手段都是通过替换CA证书的方式进行攻击，浏览器会识别出风险并警告。在网站开启HSTS（HTTP严格传输安全）后，chrome浏览器会拦截请求，无法访问，而一部分其他浏览器还是可以手动忽视风险，直接访问，将自己的信息暴露到中间人网络当中。</p><p><strong>Android应用开发者如果自定义的X509TrustManager不校验证书，或实现的自定义HostnameVerifier不校验域名接受任意域名，或使用setHostnameVerifier (ALLOW_ALL_HOSTNAME_VERIFIER)，可以直接可以通过方式1进行攻击。</strong></p><h3 id="Android-HTTPS防护"><a href="#Android-HTTPS防护" class="headerlink" title="Android HTTPS防护"></a>Android HTTPS防护</h3><p>详见<a href="#">Post not found: Android的HTTPS攻击与防护</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/xdyixia/p/11610102.html">HTTPS中CA证书的签发及使用过程</a></p><p><a href="https://blog.csdn.net/freekiteyu/article/details/76423436">一篇文章看明白 HTTP，HTTPS，SSL&#x2F;TLS 之间的关系</a></p><p><a href="https://www.zhihu.com/question/22260090/answer/648910720">CA 机构是如何保护自己私钥的？</a></p><p><a href="https://zh.m.wikipedia.org/zh-hans/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE">OSCP在线证书状态协议-维基百科</a></p><p><a href="https://www.cnblogs.com/lulianqi/p/10558719.html">HTTPS中间人攻击实践（原理·实践）</a></p><p><a href="https://blog.csdn.net/aptentity/article/details/71087607">Android HTTPS中间人劫持漏洞浅析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>精妙的位运算</title>
      <link href="/2022/06/22/%E7%B2%BE%E5%A6%99%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/06/22/%E7%B2%BE%E5%A6%99%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li><p>与运算（and）</p><p><code>&amp;</code>表示，当两个相同位对应的数都是 1 的时候，该位获得的结果才是 1，否则为 0<br>例如说<code>6 &amp; 11</code>，转换为二进制就是<code>0110 &amp; 1011</code>，结果为<code>0010</code>。<br><strong>在位运算中常常与mask进行提取对应位值的操作。</strong></p></li><li><p>或运算（or）</p><p><code>|</code>表示，当两个相同位对应的数只要有一个数 1 的时候，该位获得的结果为 1，否则为 0<br>还是用 6 和 11 这两个数做例子，就是<code>0110 | 1011 = 1111</code>。<strong>在位运算中可以起到赋值的作用。</strong></p></li><li><p>非运算（not）</p><p><code>~</code>表示将每一位按位取反（原来是 0 结果就是 1，原来是 1 结果就是 0）。<code>~110 = 001</code><br>在对Int值进行非运算时，因为计算机中存储的是补码，此时的非运算对补码进行取反后，再还原为原码后就会变为奇怪的值。<br>  <a href="https://bbs.csdn.net/wap/topics/100095663">为何~1等于-2，~0等于-1呢</a></p></li><li><p>异或运算（xor）</p><p><code>^</code>表示，当两个相同位对应的数字<strong>不同</strong>的时候为 1，否则为 0，可以用<code>A ^ B == 0</code>来判断两个数是否相等。例如说：<code>0110 ^ 1011 = 1101</code>。<strong>可以用于判断两值是否相同并且提取出改变的位</strong></p></li><li><p>左移（shl）</p><p><code>&lt;&lt;</code>表示，<code>a &lt;&lt; b</code>表示 a 左移 b 位，由于移位在末位多出来的未知数字补零。<br>在这里面可以等价为<code>a * 2^b</code>这个运算（针对十进制）。<code>0001 &lt;&lt; 1 = 0010</code> 相当于<code>1 * 2^1 = 2</code></p></li><li><p>右移（shr）</p><p><code>&gt;&gt;</code>表示，<code>a &gt;&gt; b</code>表示将 a 右移 b 位，原本的末位进行右移后会被舍弃，左边的用原有标志位补充，正数补0，负数补1。同样的，右移在十进制里面也可以近似为<code>a / (2^b)</code>的形式，不过要对结果取整，也不一定准确，只能够说意思大概如此。</p></li><li><p>无符号右移</p><p><code>&gt;&gt;&gt;</code>表示，不管正负标志位为 0 还是 1，将该数的二进制码整体右移，左边部分总是以 0 填充，右边部分舍弃。</p></li></ul><p><strong>运算优先级： <code>~</code> &gt; <code>&lt;&lt;</code> &#x3D; <code>&gt;&gt;</code>&#x3D; <code>&gt;&gt;&gt;</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code> &gt; <code>&amp;&amp;</code> &gt; <code>||</code></strong></p><span id="more"></span><h2 id="Android源码中的应用"><a href="#Android源码中的应用" class="headerlink" title="Android源码中的应用"></a>Android源码中的应用</h2><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>在<code>View.java</code>的源码中，各种View状态都是保存到类型为<code>Int</code>的<code>mViewFlags</code>字段中，每一位或多位代表一个属性的状态，例如<code>static final int ENABLED_MASK = 0x00000020;</code>代表了从二进制的右侧数第6位的值代表了当前是否为<code>ENABLED</code>状态。</p><p><code>mViewFlags</code>共使用了32位来存储状态，源码中表示为<code>0x00000000</code>，每一个0都是4位。而<code>0x00000010</code>中1为使用该4位中的最后一位，相同的，2为第三位，4为第二位，8为第一位。</p><p>修改<code>mViewFlags</code>的值在<code>setFlags(flag,mask)</code>方法中：</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> old = mViewFlags;</span><br><span class="line">    <span class="comment">// 设置新的flag值</span></span><br><span class="line">    mViewFlags = (mViewFlags &amp; ~mask) | (flags &amp; mask);</span><br><span class="line">    <span class="comment">// 判断是否值没有改变</span></span><br><span class="line">    <span class="keyword">int</span> changed = mViewFlags ^ old;</span><br><span class="line">    <span class="keyword">if</span> (changed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>(mViewFlags &amp; ~mask)</code>是将<code>mask</code>所标志的所在位原有值去除，<code>(flags &amp; mask)</code>提取出要赋值的新值，并通过或运算<code>|</code>赋值至<code>mViewFlags</code>。此时新旧两值通过异或<code>^</code>判断值是否发生了改变。如果不相等，当前<code>changed</code>中为1的位为本次修改的位。</p><blockquote><p>举个例子：假设当前<code>mViewFlags = 0x00400010</code>，此时，我们想要将当前<code>View</code>设置为<code>disable</code>状态，调用了<code>setFlags(DISABLED,ENABLED_MASK)</code>，<code>int DISABLED = 0x00000020,int ENABLED_MASK = 0x00000020</code>，那么，当前的<code>(mViewFlags &amp; ~mask) = 0x00400010 &amp; ~0x00000020 = 0x00400010 &amp; 0xffffffdf = 0x00400010</code>，而<code>(flags &amp; mask) = 0x00000020 &amp; 0x00000020 = 0x00000020</code>，最终<code>mViewFlags = 0x00400010 | 0x00000020 = 0x00400030</code>，最后<code>changed</code>计算出<code>mViewFlags ^ old</code>为<code>0x00000020</code>，也就是等于<code>mask</code>的值。</p></blockquote><p>在<code>setFlags</code>的剩余代码中，可以看到其他的位运算</p><figure class="highlight java"><figcaption><span>View.java setFlags()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((changed &amp; FOCUSABLE) != <span class="number">0</span>)&#123; <span class="comment">// 等于0则说明对应位没有发生变化，不等于0则说明发生了变化</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((old &amp; FOCUSABLE) == FOCUSABLE) &#123;<span class="comment">// FOCUSABLE此时相当于一个mask，取出对应位进行值比较</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">mPrivateFlags |= PFLAG_DRAWN; <span class="comment">// 赋值新的属性值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="位掩码BitMask的作用"><a href="#位掩码BitMask的作用" class="headerlink" title="位掩码BitMask的作用"></a>位掩码BitMask的作用</h4><p>mask标记了某一组属性所使用的一个或多个位，在获取对应属性状态时可以对mask进行<code>&amp;</code>运算获得对应的值，屏蔽其他位的影响。保证了一定的安全性、可靠性。</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p><code>MeasureSpec</code>是一个32位的int值，高2位为<code>SpecMode</code>，低30位为<code>SpecSize</code></p><figure class="highlight java"><figcaption><span>View.MeasureSpec.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// SpecMode的位掩码 0x30000000</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与位掩码and运算得出SpecMode</span></span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去除SpecMode所在位，剩下位即是Size</span></span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与View的flag赋值一样，先清除之前设置的值，后进行and运算赋值</span></span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算的优缺点"><a href="#位运算的优缺点" class="headerlink" title="位运算的优缺点"></a>位运算的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>省去了创建过多的属性变量，将多个属性集中到一个<code>Int</code>中进行管理</li><li>运算效率高，并且可以同时进行多个属性的赋值、修改操作。例如<code>setFlags(A|B,A_MASK|B_MASK)</code></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不经常使用的话看起来太费劲，并不直观。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://conorlee.top/2019/12/08/Android-bits-operation/">弄懂 Android 源码中那些巧妙位运算</a></p><p><a href="https://juejin.cn/post/6844903772854943757">谈谈位运算和在Android中的运用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android屏幕适配知识总结</title>
      <link href="/2022/06/15/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/15/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念解释"><a href="#1-概念解释" class="headerlink" title="1. 概念解释"></a>1. 概念解释</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>手机对角线的物理尺寸，单位：英寸（inch），1英寸&#x3D;2.54cm</p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>手机在横向、纵向上的像素点数的总和，由横向像素数 * 纵向像素数表示（1280*720），每个像素都是1px</p><h4 id="屏幕PPI（屏幕像素密度）"><a href="#屏幕PPI（屏幕像素密度）" class="headerlink" title="屏幕PPI（屏幕像素密度）"></a>屏幕PPI（屏幕像素密度）</h4><p>表示每英寸像素数，则在相同尺寸下，PPI越高，则越清晰。在PPI相同的情况下，屏幕尺寸越大，越模糊。</p><p><img src="/images/PPI%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99.webp" alt="PPI计算规则"></p><p>eg：小米8的像素密度为402PPI</p><h4 id="DPI"><a href="#DPI" class="headerlink" title="DPI"></a>DPI</h4><p>是印刷业使用的单位，其表示的是打印纸上每一英寸包含的墨点数量，<em>网络上的观点是Google误用了该单位</em>。在android中可以将PPI与DPI等价看待。</p><p>物理上DPI值是一个固定值，无法修改。但Android系统中的<code>densityDpi</code>参数可以通过root或adb命令修改。修改后会有一个<code>Physical density</code> 与<code>Override density</code>。</p><h3 id="Density"><a href="#Density" class="headerlink" title="Density"></a>Density</h3><ul><li><code>DisplayMetrics.density</code><br>  该density是为了方便px与dp的转换，额外提供了此参数，density &#x3D; densityDpi &#x2F; 160。</li><li><code>adb shell wm density</code><br>  这个density其实就是dpi的概念。</li></ul><p><em>很多文章中的density也就是指的是dpi</em>。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>密度无关像素(density-independent pixel)，与终端上的实际物理像素点无关。</p><p>在dpi &#x3D; 160的设备上，1dp&#x3D;1px。当dpi提升到240时，1dp所能表示的像素点提高，扩大到(240&#x2F;160)&#x3D;1.5倍，此时1dp&#x3D;1.5dp。</p><p>dp与px转换可以使用 <code>px = dp * (densityDpi / 160)</code>或者<code>px = dp * density</code>。</p><h3 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h3><p>可缩放像素，与dp基本相同，用于字体大小设置。唯一不同就是sp会随着系统设置的字体缩放进行缩放。</p><span id="more"></span><h2 id="2-适配方案"><a href="#2-适配方案" class="headerlink" title="2.适配方案"></a>2.适配方案</h2><h5 id="为什么不使用Android的dp适配方案"><a href="#为什么不使用Android的dp适配方案" class="headerlink" title="为什么不使用Android的dp适配方案"></a>为什么不使用Android的dp适配方案</h5><blockquote><p>屏幕分辨率为：1920*1080，屏幕尺寸为5吋的话，那么dpi为440。假设我们UI设计图是按屏幕宽度为360dp来设计的，那这样会存在什么问题呢？<br>在上述设备上，屏幕宽度其实为1080&#x2F;(440&#x2F;160)&#x3D;392.7dp，也就是屏幕是比设计图要宽的。这种情况下， 即使使用dp即使写了最大的dp值，也无法填充满屏幕。 同时还存在部分设备屏幕宽度不足360dp，这时就会导致按360dp宽度来开发实际显示不全的情况。</p></blockquote><p><strong>会导致按设计图换算过来的最大尺寸小于设备实际最大尺寸</strong></p><h3 id="使用RelativeLayout、ConstraintLayout进行百分比布局"><a href="#使用RelativeLayout、ConstraintLayout进行百分比布局" class="headerlink" title="使用RelativeLayout、ConstraintLayout进行百分比布局"></a>使用RelativeLayout、ConstraintLayout进行百分比布局</h3><p>如果只考虑控件大小与位置情况，使用此方案可以解决大部分问题，但对于涉及到TextView等文字大小显示问题，依旧存在上述dp方案所存在的缺陷问题。（相同sp实际在不同手机中显示的大小不一致）</p><h3 id="尺寸（size）限定符适配"><a href="#尺寸（size）限定符适配" class="headerlink" title="尺寸（size）限定符适配"></a>尺寸（size）限定符适配</h3><p>将设计图的尺寸作为基准，比如设计图为360x640，手机实际的分辨率根据这个基准宽高生成对应的尺寸文件。</p><p>例如一款720x1280的手机：</p><p>宽为720，将宽度分为360份，取值为x1到x360，则取值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dimen name&#x3D;&quot;x1&quot;&gt;2.0px&lt;&#x2F;dimen&gt;</span><br><span class="line">&lt;dimen name&#x3D;&quot;x2&quot;&gt;4.0px&lt;&#x2F;dimen&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>高也同理，生成相应的y1,y2…y640的数值。</p><p>将生成的dimens文件放到values-720x1280中，开发中使用R.dimens.x120，R.dimens.y60进行布局开发。</p><p><strong>如果手机实际尺寸没有找到对应的尺寸限定符，就会去默认的dimens中取尺寸</strong></p><p><strong>缺点：</strong></p><ol><li><p>需要生成大量的dimes文件。该方案为了适配及其小众的尺寸手机，会占用大量存储空间，导致增加安装包的大小。即使生成了大量的文件，也不可能覆盖不到全部的机型。</p></li><li><p>手机实际尺寸比例可能与设计稿不同，导致UI拉伸。设计图可能是16:9，而手机可能是16:10等其他尺寸。</p></li></ol><h3 id="最小宽度（Smallest-width）限定符"><a href="#最小宽度（Smallest-width）限定符" class="headerlink" title="最小宽度（Smallest-width）限定符"></a>最小宽度（Smallest-width）限定符</h3><p>同尺寸限定符适配同理，通过生成大量的dimen文件期望覆盖大量机型尺寸。与尺寸限定符不同的是，尺寸限定符在没有匹配到相应的限定符时，会直接去默认的dimen中寻找尺寸，而sw限定符如果没有找到与自己相同的文件夹，会找小一点的最近dimens，这样，只要dimens文件夹生成的间隔控制的得当，UI也不会有很大的偏差，也不需要占用大量的安装包空间。</p><p>系统会将屏幕较小的那一边的尺寸计算为dp，计算后的值就去匹配对应限定符。</p><blockquote><p>比如分辨率为1280x720，densityDpi为240dpi的设备。短边为720px，此设备的denstiy&#x3D;240&#x2F;160&#x3D;1.5，那么最小宽度即为720&#x2F;1.5&#x3D;480dp (px &#x3D; dp * density)，这样这个设备会从value-sw480dp的文件夹下取资源。</p></blockquote><p>而每个限定符文件夹中的dimens的生成规则和尺寸限定符相同，按照设计图的尺寸与最小宽度dp进行比例计算</p><blockquote><p>假如设计图的分辨率为1920x1080，设备计算出的最小宽度为sw440dp，那么设计图中的1px &#x3D; 440dp&#x2F;1080 &#x3D; 0.407dp，依据此规则依次生成其他尺寸的px所对应的dp值即可。</p></blockquote><p>选用最小宽度进行适配还有一个好处是布局过程中UI的宽高都使用一个边生成的尺寸进行开发，不像尺寸适配符宽取x的值，高取y的值，使用两个边的尺寸开发，当出现屏幕尺寸比例与设计图比例不相同的时候，不会被拉伸。</p><p>更多的限定符见<a href="https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn">限定符表</a></p><h3 id="头条适配方案"><a href="#头条适配方案" class="headerlink" title="头条适配方案"></a>头条适配方案</h3><p>Android原生dp方案最大的缺点是每个View的dp是写死不变的，但是手机最大的dp值随着尺寸的变化而变化。而头条方案保证了设计图中标注的最大dp值转换出的px值为都为手机的最大尺寸。</p><p>头条方案通过计算屏幕尺寸与设计图的比例，计算出<code>targetDensity = screenWidth / uiWidth;</code></p><p>动态修改<code>DisplayMetrics#density </code>,<code>DisplayMetrics#densityDpi</code>,参数，使得系统在将xml中的dp值转换为px时，<code>px = dp * targetDensity</code>，保证了在各个屏幕尺寸的一致性。</p><p>在转换sp时，<code>DisplayMetrics#scaledDensity(字体的缩放因子)</code>需要对系统字体缩放进行进一步处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetScaledDensity &#x3D; targetDensity  * (scaledDensity &#x2F; density)</span><br></pre></td></tr></table></figure><p>并需要在<code>Application#registerComponentCallbacks</code> 注册下 <code>onConfigurationChanged</code>监听字体缩放变化，实时更改最新的<code>targetScaledDensity</code>。</p><p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA">一种极低成本的Android屏幕适配方式</a></p><p><a href="https://juejin.cn/post/6844903661819133960">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p><p><a href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a></p><h2 id="其他尺寸问题"><a href="#其他尺寸问题" class="headerlink" title="其他尺寸问题"></a>其他尺寸问题</h2><h3 id="getDimension、getDimensionPixelOffset-和-getDimensionPixelSize区别"><a href="#getDimension、getDimensionPixelOffset-和-getDimensionPixelSize区别" class="headerlink" title="getDimension、getDimensionPixelOffset 和 getDimensionPixelSize区别"></a>getDimension、getDimensionPixelOffset 和 getDimensionPixelSize区别</h3><ul><li><p>相同点：返回获取某个dimen的值，如果dimen单位是dp或sp，则需要将其乘以density（屏幕密度）；如果单位是px，则不用。</p></li><li><p>不同点：<br><code>getDimension</code>：返回类型为float，<br><code>getDimensionPixelSize</code>：返回类型为int，由浮点型转成整型时，采用四舍五入原则。<br><code>getDimensionPixelOffset</code>：返回类型为int，由浮点型转成整型时，原则是忽略小数点部分。</p></li></ul><h3 id="TextView中的setTextSize参数问题"><a href="#TextView中的setTextSize参数问题" class="headerlink" title="TextView中的setTextSize参数问题"></a>TextView中的setTextSize参数问题</h3><figure class="highlight java"><figcaption><span>TextView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSize</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> size)</span> </span></span><br></pre></td></tr></table></figure><p>其实很好理解，参数unit就是代表传入的size的类型，如果unit为<code>TypedValue.COMPLEX_UNIT_SP</code>,那么就会将传入的size按sp的方式计算（乘density），最终转化为px值。如果直接传入<code>TypedValue.COMPLEX_UNIT_PX</code>，就不需要转换为px值。</p><p><strong>一个小例子：</strong></p><figure class="highlight java"><figcaption><span>example.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setTextSize(TypedValue.COMPLEX_UNIT_SP,getResources().getDimension(R.dimen.fontsize))</span><br></pre></td></tr></table></figure><figure class="highlight xml"><figcaption><span>app/src/main/res/values/dimens.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;font1&quot;</span>&gt;</span>18sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况时，<code>getResources().getDimension()</code>在获取值的时候已经将18*density转换为px值后，然后再TextView中设置时又再次*density，相当于TextView最终设置到的字体大小为18*density*density。</p><h2 id="附录：常见密度限定符对应表"><a href="#附录：常见密度限定符对应表" class="headerlink" title="附录：常见密度限定符对应表"></a>附录：常见密度限定符对应表</h2><table><thead><tr><th align="left">密度限定符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>ldpi</code></td><td align="left">适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源。</td></tr><tr><td align="left"><code>mdpi</code></td><td align="left">适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度）。</td></tr><tr><td align="left"><code>hdpi</code></td><td align="left">适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源。</td></tr><tr><td align="left"><code>xhdpi</code></td><td align="left">适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源。</td></tr><tr><td align="left"><code>xxhdpi</code></td><td align="left">适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源。</td></tr><tr><td align="left"><code>xxxhdpi</code></td><td align="left">适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源。</td></tr><tr><td align="left"><code>nodpi</code></td><td align="left">适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源。</td></tr><tr><td align="left"><code>tvdpi</code></td><td align="left">适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle构建流程分析（一）- 初始化与Task创建</title>
      <link href="/2022/01/12/gradle%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
      <url>/2022/01/12/gradle%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p><em>基于AGP3.4.2版本进行分析</em></p><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p>在build.gradle中添加<code>implementation &#39;com.android.tools.build:gradle:3.4.2&#39;</code>Sync后即可看到源码</p><h2 id="插件入口"><a href="#插件入口" class="headerlink" title="插件入口"></a>插件入口</h2><p>获取到源码后，看&#x2F;META-INF&#x2F;gradle-plugins&#x2F;com.android.application.properties文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class&#x3D;com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure><p>可以看出插件“com.android.application”对应为<strong>AppPlugin.java</strong>，在同级目录下的com.android.library.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class&#x3D;com.android.build.gradle.LibraryPlugin</span><br></pre></td></tr></table></figure><p>可以看出插件“com.android.library”为<strong>LibraryPlugin.java</strong></p><span id="more"></span><h2 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h2><p><code>AppPlugin</code>与<code>LibraryPlugin</code>中并没有实现<code>Plugin#apply()</code>方法，该方法是由其父类<code>BasePlugin</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BasePlugin#apply()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="meta">@NonNull</span> Project project)</span> </span>&#123;</span><br><span class="line">    CrashReporting.runAction(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">            <span class="comment">// AppPlugin与LibraryPlugin即其他插件通用逻辑</span></span><br><span class="line">                basePluginApply(project);</span><br><span class="line">                <span class="comment">// 子类按需添加的功能</span></span><br><span class="line">                pluginSpecificApply(project);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pluginSpecificApply</code>为一个抽象方法，供子类在<code>apply()</code>方法中添加自定义功能。<code>AppPlugin</code>中为空实现，在<code>LibraryPlugin</code>中添加了一个<code>assembleDefault</code>的Task。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LibraryPlugin#pluginSpecificApply()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pluginSpecificApply</span><span class="params">(<span class="meta">@NonNull</span> Project project)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Default assemble task for the default-published artifact.</span></span><br><span class="line">    <span class="comment">// This is needed for the prepare task on the consuming project.</span></span><br><span class="line">    project.getTasks().create(<span class="string">&quot;assembleDefault&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>basePluginApply</code>方法为核心方法，其中处理了整个插件的初始化工作，Gradle版本、依赖检查、预设build任务完成后的清理工作等。其中最重要的是设置Extension与创建Task</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BasePlugin#basePluginApply()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">basePluginApply</span><span class="params">(<span class="meta">@NonNull</span> Project project)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....初始化等工作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个目前试验性的参数，目前还没启用</span></span><br><span class="line">    <span class="keyword">if</span> (!projectOptions.get(BooleanOption.ENABLE_NEW_DSL_AND_API)) &#123;</span><br><span class="line"><span class="comment">// 创建核心类、下载缺少的sdk等</span></span><br><span class="line">        threadRecorder.record(</span><br><span class="line">                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,</span><br><span class="line">                project.getPath(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">this</span>::configureProject);</span><br><span class="line"><span class="comment">// 创建配置表</span></span><br><span class="line">        threadRecorder.record(</span><br><span class="line">                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,</span><br><span class="line">                project.getPath(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">this</span>::configureExtension);</span><br><span class="line"><span class="comment">// 创建Task</span></span><br><span class="line">        threadRecorder.record(</span><br><span class="line">                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,</span><br><span class="line">                project.getPath(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">this</span>::createTasks);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要重点关注3个方法<code>configureProject()</code>,<code>configureExtension()</code>,<code>createTasks()</code>。</p><h3 id="配置环境-configureProject"><a href="#配置环境-configureProject" class="headerlink" title="配置环境 - configureProject()"></a>配置环境 - configureProject()</h3><p><code>configureProject</code>中创建了下文所需的<code>androidBuilder</code>、<code>globalScope</code>核心类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BasePlugin#configureProject()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureProject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    extraModelInfo = <span class="keyword">new</span> ExtraModelInfo(project.getPath(), projectOptions, project.getLogger());</span><br><span class="line"></span><br><span class="line">    sdkHandler = <span class="keyword">new</span> SdkHandler(project, getLogger());</span><br><span class="line">    <span class="comment">// 下载缺少的sdk</span></span><br><span class="line">    <span class="keyword">if</span> (!gradle.getStartParameter().isOffline()</span><br><span class="line">            &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)) &#123;</span><br><span class="line">        SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());</span><br><span class="line">        sdkHandler.setSdkLibData(sdkLibData);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 创建主构建器，合并menifest、合并resources等实现都是由该类完成的</span></span><br><span class="line">    AndroidBuilder androidBuilder =</span><br><span class="line">            <span class="keyword">new</span> AndroidBuilder(</span><br><span class="line">                    project == project.getRootProject() ? project.getName() : project.getPath(),</span><br><span class="line">                    creator,</span><br><span class="line">                    <span class="keyword">new</span> GradleProcessExecutor(project),</span><br><span class="line">                    <span class="keyword">new</span> GradleJavaProcessExecutor(project),</span><br><span class="line">                    extraModelInfo.getSyncIssueHandler(),</span><br><span class="line">                    extraModelInfo.getMessageReceiver(),</span><br><span class="line">                    getLogger());</span><br><span class="line">    <span class="comment">// DataBinding相关</span></span><br><span class="line">    dataBindingBuilder = <span class="keyword">new</span> DataBindingBuilder();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的数据存储</span></span><br><span class="line">    globalScope =</span><br><span class="line">            <span class="keyword">new</span> GlobalScope(</span><br><span class="line">                    project,</span><br><span class="line">                    <span class="keyword">new</span> ProjectWrapper(project),</span><br><span class="line">                    projectOptions,</span><br><span class="line">                    dslScope,</span><br><span class="line">                    androidBuilder,</span><br><span class="line">                    sdkHandler,</span><br><span class="line">                    registry,</span><br><span class="line">                    buildCache);</span><br><span class="line"></span><br><span class="line">    project.getTasks()</span><br><span class="line">            .getByName(<span class="string">&quot;assemble&quot;</span>)</span><br><span class="line">            .setDescription(</span><br><span class="line">                    <span class="string">&quot;Assembles all variants of all applications and secondary packages.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call back on execution. This is called after the whole build is done (not</span></span><br><span class="line">    <span class="comment">// after the current project is done).</span></span><br><span class="line">    <span class="comment">// This is will be called for each (android) projects though, so this should support</span></span><br><span class="line">    <span class="comment">// being called 2+ times.</span></span><br><span class="line">    gradle.addBuildListener(</span><br><span class="line">            <span class="keyword">new</span> BuildListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildStarted</span><span class="params">(<span class="meta">@NonNull</span> Gradle gradle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settingsEvaluated</span><span class="params">(<span class="meta">@NonNull</span> Settings settings)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">projectsLoaded</span><span class="params">(<span class="meta">@NonNull</span> Gradle gradle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">projectsEvaluated</span><span class="params">(<span class="meta">@NonNull</span> Gradle gradle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFinished</span><span class="params">(<span class="meta">@NonNull</span> BuildResult buildResult)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Do not run buildFinished for included project in composite build.</span></span><br><span class="line">                  <span class="comment">// 清理工作</span></span><br><span class="line">                    <span class="keyword">if</span> (buildResult.getGradle().getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ModelBuilder.clearCaches();</span><br><span class="line">                    sdkHandler.unload();</span><br><span class="line">                    threadRecorder.record(</span><br><span class="line">                            ExecutionType.BASE_PLUGIN_BUILD_FINISHED,</span><br><span class="line">                            project.getPath(),</span><br><span class="line">                            <span class="keyword">null</span>,</span><br><span class="line">                            () -&gt; &#123;</span><br><span class="line">                                WorkerActionServiceRegistry.INSTANCE</span><br><span class="line">                                        .shutdownAllRegisteredServices(</span><br><span class="line">                                                ForkJoinPool.commonPool());</span><br><span class="line">                                Main.clearInternTables();</span><br><span class="line">                            &#125;);</span><br><span class="line">                    DeprecationReporterImpl.Companion.clean();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    createLintClasspathConfiguration(project);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Extension-configureExtension"><a href="#创建Extension-configureExtension" class="headerlink" title="创建Extension - configureExtension()"></a>创建Extension - configureExtension()</h3><p>在<code>configureExtension</code>中创建了<code>Extension</code>，使得我们可以在build.gradle中的使用这样的代码块</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">  buildToolsVersion <span class="string">&#x27;28.0.3&#x27;</span></span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId <span class="string">&quot;com.xxx&quot;</span></span><br><span class="line">          versionCode <span class="number">1157</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Extension</code>详解可以参照官方文档：<a href="https://docs.gradle.org/current/userguide/custom_plugins.html">Gradle Plugin</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BasePlugin#configureExtension()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectFactory objectFactory = project.getObjects();</span><br><span class="line">  <span class="comment">// buildTypes</span></span><br><span class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer =</span><br><span class="line">            project.container(</span><br><span class="line">                    BuildType.class,</span><br><span class="line">                    <span class="keyword">new</span> BuildTypeFactory(</span><br><span class="line">                            objectFactory,</span><br><span class="line">                            project,</span><br><span class="line">                            extraModelInfo.getSyncIssueHandler(),</span><br><span class="line">                            extraModelInfo.getDeprecationReporter()));</span><br><span class="line">  <span class="comment">// productFlavors</span></span><br><span class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer =</span><br><span class="line">            project.container(</span><br><span class="line">                    ProductFlavor.class,</span><br><span class="line">                    <span class="keyword">new</span> ProductFlavorFactory(</span><br><span class="line">                            objectFactory,</span><br><span class="line">                            project,</span><br><span class="line">                            extraModelInfo.getDeprecationReporter(),</span><br><span class="line">                            project.getLogger()));</span><br><span class="line">  <span class="comment">// signingConfigs</span></span><br><span class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer =</span><br><span class="line">            project.container(</span><br><span class="line">                    SigningConfig.class,</span><br><span class="line">                    <span class="keyword">new</span> SigningConfigFactory(</span><br><span class="line">                            objectFactory,</span><br><span class="line">                            GradleKeystoreHelper.getDefaultDebugKeystoreLocation()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs =</span><br><span class="line">            project.container(BaseVariantOutput.class);</span><br><span class="line"></span><br><span class="line">    project.getExtensions().add(<span class="string">&quot;buildOutputs&quot;</span>, buildOutputs);</span><br><span class="line"><span class="comment">// sourceSets 可以配置资源的位置，</span></span><br><span class="line">    sourceSetManager =</span><br><span class="line">            <span class="keyword">new</span> SourceSetManager(</span><br><span class="line">                    project,</span><br><span class="line">                    isPackagePublished(),</span><br><span class="line">                    globalScope.getDslScope(),</span><br><span class="line">                    <span class="keyword">new</span> DelayedActionsExecutor());</span><br><span class="line"><span class="comment">// 根据子类创建Extension</span></span><br><span class="line">    extension =</span><br><span class="line">            createExtension(</span><br><span class="line">                    project,</span><br><span class="line">                    projectOptions,</span><br><span class="line">                    globalScope,</span><br><span class="line">                    sdkHandler,</span><br><span class="line">                    buildTypeContainer,</span><br><span class="line">                    productFlavorContainer,</span><br><span class="line">                    signingConfigContainer,</span><br><span class="line">                    buildOutputs,</span><br><span class="line">                    sourceSetManager,</span><br><span class="line">                    extraModelInfo);</span><br><span class="line"><span class="comment">// 存储到globalScope中</span></span><br><span class="line">    globalScope.setExtension(extension);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对app、lib进行不同的实现</span></span><br><span class="line">    variantFactory = createVariantFactory(globalScope, extension);</span><br><span class="line"><span class="comment">// 创建TaskManager</span></span><br><span class="line">    taskManager =</span><br><span class="line">            createTaskManager(</span><br><span class="line">                    globalScope,</span><br><span class="line">                    project,</span><br><span class="line">                    projectOptions,</span><br><span class="line">                    dataBindingBuilder,</span><br><span class="line">                    extension,</span><br><span class="line">                    sdkHandler,</span><br><span class="line">                    variantFactory,</span><br><span class="line">                    registry,</span><br><span class="line">                    threadRecorder);</span><br><span class="line"></span><br><span class="line">    variantManager =</span><br><span class="line">            <span class="keyword">new</span> VariantManager(</span><br><span class="line">                    globalScope,</span><br><span class="line">                    project,</span><br><span class="line">                    projectOptions,</span><br><span class="line">                    extension,</span><br><span class="line">                    variantFactory,</span><br><span class="line">                    taskManager,</span><br><span class="line">                    sourceSetManager,</span><br><span class="line">                    threadRecorder);</span><br><span class="line"></span><br><span class="line">    registerModels(registry, globalScope, variantManager, extension, extraModelInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个signingConfigs配置即会调用一次addSigningConfig，使得将所有的签名文件存放到一个map中。</span></span><br><span class="line">  <span class="comment">// 即使不配置signingConfigs也会有一个默认的DEBUG签名。</span></span><br><span class="line">    <span class="comment">// map the whenObjectAdded callbacks on the containers.</span></span><br><span class="line">    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class="line"></span><br><span class="line">    buildTypeContainer.whenObjectAdded(</span><br><span class="line">            buildType -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.getClass().isAssignableFrom(DynamicFeaturePlugin.class)) &#123;</span><br><span class="line">                    SigningConfig signingConfig =</span><br><span class="line">                            signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class="line">                  <span class="comment">// 将项目的默认签名设置为DEBUG签名</span></span><br><span class="line">                    buildType.init(signingConfig);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// initialize it without the signingConfig for dynamic-features.</span></span><br><span class="line">                    buildType.init();</span><br><span class="line">                &#125;</span><br><span class="line">                variantManager.addBuildType(buildType);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">// 每个flavor也会调用addProductFlavor方法，分析每个flavor中独立配置的参数列表，</span></span><br><span class="line">  <span class="comment">// 包括这个flover独立的minSdkVersion、targetSdkVersion等，构建一个ProductFlavorData数据</span></span><br><span class="line">    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map whenObjectRemoved on the containers to throw an exception.</span></span><br><span class="line">    signingConfigContainer.whenObjectRemoved(</span><br><span class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">&quot;Removing signingConfigs is not supported.&quot;</span>));</span><br><span class="line">    buildTypeContainer.whenObjectRemoved(</span><br><span class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">&quot;Removing build types is not supported.&quot;</span>));</span><br><span class="line">    productFlavorContainer.whenObjectRemoved(</span><br><span class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">&quot;Removing product flavors is not supported.&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在signingConfig创建一个debug dsl，在buildTypes中创建debug、release的dsl</span></span><br><span class="line">    <span class="comment">// create default Objects, signingConfig first as its used by the BuildTypes.</span></span><br><span class="line">    variantFactory.createDefaultComponents(</span><br><span class="line">            buildTypeContainer, productFlavorContainer, signingConfigContainer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在configureExtension方法中，首先配置了我们经常在build.gradle中看到的一些参数，例如signingConfigs、productFlavors等，并通过<code>whenObjectAdded</code>监听将填入的数据收集到variantManager中的map中。在抽象方法<code>createExtension</code>中会根据子类的不同进行创建不同的<code>Extension</code>。具体都是直接调用<code>project.getExtensions().create(&quot;android&quot;,getExtensionClass(),xxxxxx)</code>方法进行创建，AppPlugin<code>getExtensionClass()</code>返回的是<code>BaseAppModuleExtension.class</code>，LibraryPlugin方法返回的是<code>LibraryExtension.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppPlugin#getExtensionClass()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends AppExtension&gt; getExtensionClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> BaseAppModuleExtension.class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LibraryPlugin#getExtensionClass()</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends BaseExtension&gt; getExtensionClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> LibraryExtension.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，也创建了<code>createTasks</code>方法中所需的参数：taskManager、variantManager。</p><h3 id="创建Task列表-createTasks"><a href="#创建Task列表-createTasks" class="headerlink" title="创建Task列表-createTasks()"></a>创建Task列表-createTasks()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadRecorder.record(</span><br><span class="line">            ExecutionType.TASK_MANAGER_CREATE_TASKS,</span><br><span class="line">            project.getPath(),</span><br><span class="line">            <span class="keyword">null</span>,</span><br><span class="line">            () -&gt; taskManager.createTasksBeforeEvaluate()); <span class="comment">// 创建一些不依赖flover的Task</span></span><br><span class="line"></span><br><span class="line">    project.afterEvaluate(</span><br><span class="line">            CrashReporting.afterEvaluate(</span><br><span class="line">                    p -&gt; &#123;</span><br><span class="line">                      <span class="comment">// 执行延时任务，一般为空任务</span></span><br><span class="line">                        sourceSetManager.runBuildableArtifactsActions();</span><br><span class="line"></span><br><span class="line">                        threadRecorder.record(</span><br><span class="line">                                ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,</span><br><span class="line">                                project.getPath(),</span><br><span class="line">                                <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">this</span>::createAndroidTasks);<span class="comment">// 开始创建核心Task</span></span><br><span class="line">                    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>taskManager.createTasksBeforeEvaluate()</code>中，创建了<code>preBuild</code>、lint相关的task。构建核心task是在createAndroidTasks方法中创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createAndroidTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 参数的检查与设置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lint </span></span><br><span class="line">    taskManager.configureCustomLintChecks();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Task的核心方法，会对buildTypes 和 flover进行组合，并创建合并后tasks</span></span><br><span class="line">    List&lt;VariantScope&gt; variantScopes = variantManager.createAndroidTasks();</span><br><span class="line"></span><br><span class="line">    ApiObjectFactory apiObjectFactory =</span><br><span class="line">            <span class="keyword">new</span> ApiObjectFactory(</span><br><span class="line">                    globalScope.getAndroidBuilder(),</span><br><span class="line">                    extension,</span><br><span class="line">                    variantFactory,</span><br><span class="line">                    project.getObjects());</span><br><span class="line">    <span class="keyword">for</span> (VariantScope variantScope : variantScopes) &#123;</span><br><span class="line">        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class="line">        apiObjectFactory.create(variantData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure no SourceSets were added through the DSL without being properly configured</span></span><br><span class="line">    <span class="comment">// Only do it if we are not restricting to a single variant (with Instant</span></span><br><span class="line">    <span class="comment">// Run or we can find extra source set</span></span><br><span class="line">    <span class="keyword">if</span> (projectOptions.get(StringOption.IDE_RESTRICT_VARIANT_NAME) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sourceSetManager.checkForUnconfiguredSourceSets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// must run this after scopes are created so that we can configure kotlin</span></span><br><span class="line">    <span class="comment">// kapt tasks</span></span><br><span class="line">    taskManager.addDataBindingDependenciesIfNecessary(</span><br><span class="line">            extension.getDataBinding(), variantManager.getVariantScopes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the global lint task that depends on all the variants</span></span><br><span class="line">    taskManager.configureGlobalLintTask(variantManager.getVariantScopes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flavorDimensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (extension.getFlavorDimensionList() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        flavorDimensionCount = extension.getFlavorDimensionList().size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    taskManager.createAnchorAssembleTasks(</span><br><span class="line">            variantScopes,</span><br><span class="line">            extension.getProductFlavors().size(),</span><br><span class="line">            flavorDimensionCount,</span><br><span class="line">            variantFactory.getVariantConfigurationTypes().size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now publish all variant artifacts.</span></span><br><span class="line">    <span class="keyword">for</span> (VariantScope variantScope : variantManager.getVariantScopes()) &#123;</span><br><span class="line">        variantManager.publishBuildArtifacts(variantScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkSplitConfiguration();</span><br><span class="line">    variantManager.setHasCreatedTasks(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;VariantScope&gt; <span class="title">createAndroidTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    variantFactory.validateModel(<span class="keyword">this</span>);</span><br><span class="line">    variantFactory.preVariantWork(project);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (variantScopes.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 拼接flover与buildType</span></span><br><span class="line">        populateVariantDataList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create top level test tasks.</span></span><br><span class="line">    taskManager.createTopLevelTestTasks(!productFlavors.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> VariantScope variantScope : variantScopes) &#123;</span><br><span class="line">      <span class="comment">// 根据每个组合创建Task</span></span><br><span class="line">        createTasksForVariantData(variantScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    taskManager.createSourceSetArtifactReportTask(globalScope);</span><br><span class="line"></span><br><span class="line">    taskManager.createReportTasks(variantScopes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> variantScopes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(<span class="keyword">final</span> VariantScope variantScope)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BaseVariantData variantData = variantScope.getVariantData();</span><br><span class="line">    <span class="keyword">final</span> VariantType variantType = variantData.getType();</span><br><span class="line">    <span class="keyword">final</span> GradleVariantConfiguration variantConfig = variantScope.getVariantConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与variantData拼接名称创建assembleTask</span></span><br><span class="line">    taskManager.createAssembleTask(variantData);</span><br><span class="line">    <span class="keyword">if</span> (variantType.isBaseModule()) &#123;</span><br><span class="line">        taskManager.createBundleTask(variantData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (variantType.isTestComponent()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建其他Task</span></span><br><span class="line">        taskManager.createTasksForVariantScope(variantScope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationTaskManager#createTasksForVariantScope()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantScope</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> VariantScope variantScope)</span> </span>&#123;</span><br><span class="line">    createAnchorTasks(variantScope);</span><br><span class="line">    createCheckManifestTask(variantScope);</span><br><span class="line"></span><br><span class="line">    handleMicroApp(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create all current streams (dependencies mostly at this point)</span></span><br><span class="line">    createDependencyStreams(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to publish the applicationId.</span></span><br><span class="line">    createApplicationIdWriterTask(variantScope);</span><br><span class="line"></span><br><span class="line">    taskFactory.register(<span class="keyword">new</span> MainApkListPersistence.CreationAction(variantScope));</span><br><span class="line">    createBuildArtifactReportTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to process the manifest(s)</span></span><br><span class="line">    createMergeApkManifestsTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to create the res values</span></span><br><span class="line">    createGenerateResValuesTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to compile renderscript files.</span></span><br><span class="line">    createRenderscriptTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to merge the resource folders</span></span><br><span class="line">    createMergeResourcesTask(</span><br><span class="line">            variantScope,</span><br><span class="line">            <span class="keyword">true</span>,</span><br><span class="line">            Sets.immutableEnumSet(MergeResources.Flag.PROCESS_VECTOR_DRAWABLES));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add tasks to compile shader</span></span><br><span class="line">    createShaderTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to merge the asset folders</span></span><br><span class="line">    createMergeAssetsTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to create the BuildConfig class</span></span><br><span class="line">    createBuildConfigTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to process the Android Resources and generate source files</span></span><br><span class="line">    createApkProcessResTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to process the java resources</span></span><br><span class="line">    createProcessJavaResTask(variantScope);</span><br><span class="line"></span><br><span class="line">    createAidlTask(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add external native build tasks</span></span><br><span class="line">    createExternalNativeBuildJsonGenerators(variantScope);</span><br><span class="line">    createExternalNativeBuildTasks(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a task to merge the jni libs folders</span></span><br><span class="line">    createMergeJniLibFoldersTasks(variantScope);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add feature related tasks if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (variantScope.getType().isBaseModule()) &#123;</span><br><span class="line">        <span class="comment">// Base feature specific tasks.</span></span><br><span class="line">        taskFactory.register(<span class="keyword">new</span> FeatureSetMetadataWriterTask.CreationAction(variantScope));</span><br><span class="line"></span><br><span class="line">        createValidateSigningTask(variantScope);</span><br><span class="line">        <span class="comment">// Add a task to produce the signing config file.</span></span><br><span class="line">        taskFactory.register(<span class="keyword">new</span> SigningConfigWriterTask.CreationAction(variantScope));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extension.getDataBinding().isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// Create a task that will package the manifest ids(the R file packages) of all</span></span><br><span class="line">            <span class="comment">// features into a file. This file&#x27;s path is passed into the Data Binding annotation</span></span><br><span class="line">            <span class="comment">// processor which uses it to known about all available features.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// &lt;p&gt;see: &#123;@link TaskManager#setDataBindingAnnotationProcessorParams(VariantScope)&#125;</span></span><br><span class="line">            taskFactory.register(</span><br><span class="line">                    <span class="keyword">new</span> DataBindingExportFeatureApplicationIdsTask.CreationAction(</span><br><span class="line">                            variantScope));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Non-base feature specific task.</span></span><br><span class="line">        <span class="comment">// Task will produce artifacts consumed by the base feature</span></span><br><span class="line">        taskFactory.register(</span><br><span class="line">                <span class="keyword">new</span> FeatureSplitDeclarationWriterTask.CreationAction(variantScope));</span><br><span class="line">        <span class="keyword">if</span> (extension.getDataBinding().isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// Create a task that will package necessary information about the feature into a</span></span><br><span class="line">            <span class="comment">// file which is passed into the Data Binding annotation processor.</span></span><br><span class="line">            taskFactory.register(</span><br><span class="line">                    <span class="keyword">new</span> DataBindingExportFeatureInfoTask.CreationAction(variantScope));</span><br><span class="line">        &#125;</span><br><span class="line">        taskFactory.register(<span class="keyword">new</span> MergeConsumerProguardFilesTask.CreationAction(variantScope));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add data binding tasks if enabled</span></span><br><span class="line">    createDataBindingTasksIfNecessary(variantScope, MergeType.MERGE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a compile task</span></span><br><span class="line">    createCompileTask(variantScope);</span><br><span class="line"></span><br><span class="line">    createStripNativeLibraryTask(taskFactory, variantScope);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (variantScope.getVariantData().getMultiOutputPolicy().equals(MultiOutputPolicy.SPLITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extension.getBuildToolsRevision().getMajor() &lt; <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Pure splits can only be used with buildtools 21 and later&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createSplitTasks(variantScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TaskProvider&lt;BuildInfoWriterTask&gt; buildInfoWriterTask =</span><br><span class="line">            createInstantRunPackagingTasks(variantScope);</span><br><span class="line">    createPackagingTask(variantScope, buildInfoWriterTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the lint tasks, if enabled</span></span><br><span class="line">    createLintTasks(variantScope);</span><br><span class="line"></span><br><span class="line">    taskFactory.register(<span class="keyword">new</span> FeatureSplitTransitiveDepsWriterTask.CreationAction(variantScope));</span><br><span class="line"></span><br><span class="line">    createDynamicBundleTask(variantScope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置屏幕缩放后缩放距离变为双倍</title>
      <link href="/2021/05/07/%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE%E5%90%8E%E7%BC%A9%E6%94%BE%E8%B7%9D%E7%A6%BB%E5%8F%98%E4%B8%BA%E5%8F%8C%E5%80%8D/"/>
      <url>/2021/05/07/%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE%E5%90%8E%E7%BC%A9%E6%94%BE%E8%B7%9D%E7%A6%BB%E5%8F%98%E4%B8%BA%E5%8F%8C%E5%80%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="复现步骤（问题）"><a href="#复现步骤（问题）" class="headerlink" title="复现步骤（问题）"></a>复现步骤（问题）</h2><ol><li>在Android6.0系统中设置屏幕缩放，向内缩小屏幕任意范围</li><li>在一定的条件下，如关闭一个dialog风格的activity、关闭popupwindow</li><li>会发现向内缩小的屏幕尺寸变大一倍</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过Android Studio中的layout inspector分析发现：屏幕缩放的实现方式是在<code>DecorView</code>中设置padding进行屏幕变化，但出现问题后，一个id为<code>action_bar_root</code>的<code>FitWindowsLinearLayout</code>中也出现了<strong>相同数值</strong>的padding。找到相应的<code>abc_screen_simple.xml</code>后发现这个View上配置了<code>android:fitsSystemWindows=&quot;true&quot;</code></p><span id="more"></span><blockquote><p>大部分的时候，你的应用都不会在状态栏和导航栏下面显示内容，如果你需要在他们下面显示内容，则需要确保你应用的可交互控件（比如按钮）不要显示在系统窗口下面了。 android:fitsSystemWindows&#x3D;“true” 默认行为就是通过在 View 上设置和系统窗口一样高度的边框（padding ）来确保你的内容不会出现到系统窗口下面。</p><p><a href="https://blog.chengyunfeng.com/?p=905">https://blog.chengyunfeng.com/?p=905</a></p></blockquote><p>所以将这个<code>fitsSystemWindows</code>值改为false即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">        handler.post &#123;</span><br><span class="line">            <span class="comment">// 更改为false</span></span><br><span class="line">            window.decorView.findViewById&lt;View&gt;(R.id.action_bar_root).fitsSystemWindows = <span class="keyword">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> BUG总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android焦点机制</title>
      <link href="/2021/03/31/Android%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/03/31/Android%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>本篇所分析的源码为Android 28，可能与其他版本有所出入</div></article><h2 id="焦点存储与设置"><a href="#焦点存储与设置" class="headerlink" title="焦点存储与设置"></a>焦点存储与设置</h2><h3 id="焦点的标志位"><a href="#焦点的标志位" class="headerlink" title="焦点的标志位"></a>焦点的标志位</h3><p>在<code>View</code>中，自身的许多状态都是使用<code>mPrivateFlags</code>来记录，其中<code>FOCUSABLE_MASK</code>位为记录<code>View</code>的焦点状态</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mask for use with setFlags indicating bits used for focus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOCUSABLE_MASK = <span class="number">0x00000011</span>;</span><br></pre></td></tr></table></figure><p><code>View</code>的焦点焦点状态共有3种<code>NOT_FOCUSABLE</code>、<code>FOCUSABLE</code>、<code>FOCUSABLE_AUTO</code>。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This view does not want keystrokes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOT_FOCUSABLE = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This view wants keystrokes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOCUSABLE = <span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This view determines focusability automatically. This is the default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOCUSABLE_AUTO = <span class="number">0x00000010</span>;</span><br></pre></td></tr></table></figure><p>其中<code>FOCUSABLE_AUTO</code>为默认状态，当未在xml未配置<code>android:focusable</code>属性时，系统会将焦点状态设置为<code>FOCUSABLE_AUTO</code></p><span id="more"></span><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 在构造方法中设置默认值为FOCUSABLE_AUTO</span></span><br><span class="line">    viewFlagValues |= FOCUSABLE_AUTO;</span><br><span class="line">    viewFlagMasks |= FOCUSABLE_AUTO;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取xml中配置的focusable的值</span></span><br><span class="line">    <span class="keyword">case</span> com.android.internal.R.styleable.View_focusable:</span><br><span class="line">        viewFlagValues = (viewFlagValues &amp; ~FOCUSABLE_MASK) | getFocusableAttribute(a);</span><br><span class="line">        <span class="keyword">if</span> ((viewFlagValues &amp; FOCUSABLE_AUTO) == <span class="number">0</span>) &#123; <span class="comment">// 如果新flag不是FOCUSABLE_AUTO，则更改viewFlagMasks中的标志位，准备在setFlags中更改状态</span></span><br><span class="line">            viewFlagMasks |= FOCUSABLE_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (viewFlagMasks != <span class="number">0</span>) &#123; <span class="comment">// View状态发生变化进行更新flag</span></span><br><span class="line">        setFlags(viewFlagValues, viewFlagMasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFocusableAttribute</span><span class="params">(TypedArray attributes)</span> </span>&#123;</span><br><span class="line">    TypedValue val = <span class="keyword">new</span> TypedValue();</span><br><span class="line">    <span class="keyword">if</span> (attributes.getValue(com.android.internal.R.styleable.View_focusable, val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val.type == TypedValue.TYPE_INT_BOOLEAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> (val.data == <span class="number">0</span> ? NOT_FOCUSABLE : FOCUSABLE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FOCUSABLE_AUTO; <span class="comment">// 如果没配置则为FOCUSABLE_AUTO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="焦点状态的获取"><a href="#焦点状态的获取" class="headerlink" title="焦点状态的获取"></a>焦点状态的获取</h3><p><code>View</code>中获取焦点状态即是判断flag中的对应标志位</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>ViewGroup</code>中，存在一个<code>mFocused</code>属性，是当前获取了焦点的子View。但这个<code>mFocused</code>并不是直接就是视图树中当前有焦点的那个<code>View</code>，而是当前这个<code>ViewGroup</code>中的直接子<code>View</code>。当需要获取当前焦点<code>View</code>时，会递归的调用直到找到具体的<code>View</code>。在获取获取焦点状态时，不仅会判断自身是否有焦点，还有判断自己的子<code>View</code>是否也具有焦点。</p><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span> || mFocused != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="焦点状态的设置"><a href="#焦点状态的设置" class="headerlink" title="焦点状态的设置"></a>焦点状态的设置</h3><p>无论是调用了<code>View.setFocusable(Boolean)</code>还是新版本新增的api<code>View.setFocusable(int)</code>，最后都是要通过setFlags()方法进行标志位的更改</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old = mViewFlags;</span><br><span class="line">    mViewFlags = (mViewFlags &amp; ~mask) | (flags &amp; mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> changed = mViewFlags ^ old;</span><br><span class="line">    <span class="keyword">if</span> (changed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">boolean</span> shouldNotifyFocusableAvailable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If focusable is auto, update the FOCUSABLE bit.</span></span><br><span class="line">    <span class="keyword">int</span> focusableChangedByAuto = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((mViewFlags &amp; FOCUSABLE_AUTO) != <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; (changed &amp; (FOCUSABLE_MASK | CLICKABLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Heuristic only takes into account whether view is clickable.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newFocus;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; CLICKABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            newFocus = FOCUSABLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newFocus = NOT_FOCUSABLE;</span><br><span class="line">        &#125;</span><br><span class="line">        mViewFlags = (mViewFlags &amp; ~FOCUSABLE) | newFocus;</span><br><span class="line">        focusableChangedByAuto = (old &amp; FOCUSABLE) ^ (newFocus &amp; FOCUSABLE);</span><br><span class="line">        changed = (changed &amp; ~FOCUSABLE) | focusableChangedByAuto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the FOCUSABLE bit has changed */</span></span><br><span class="line">    <span class="keyword">if</span> (((changed &amp; FOCUSABLE) != <span class="number">0</span>) &amp;&amp; ((privateFlags &amp; PFLAG_HAS_BOUNDS) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((old &amp; FOCUSABLE) == FOCUSABLE)</span><br><span class="line">                &amp;&amp; ((privateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Give up focus if we are no longer focusable */</span></span><br><span class="line">            clearFocus();</span><br><span class="line">            <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                ((ViewGroup) mParent).clearFocusedInCluster();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((old &amp; FOCUSABLE) == NOT_FOCUSABLE)</span><br><span class="line">                &amp;&amp; ((privateFlags &amp; PFLAG_FOCUSED) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Tell the view system that we are now available to take focus</span></span><br><span class="line"><span class="comment">             * if no one else already has it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ViewRootImpl viewRootImpl = getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (!sAutoFocusableOffUIThreadWontNotifyParents</span><br><span class="line">                        || focusableChangedByAuto == <span class="number">0</span></span><br><span class="line">                        || viewRootImpl == <span class="keyword">null</span></span><br><span class="line">                        || viewRootImpl.mThread == Thread.currentThread()) &#123;</span><br><span class="line">                    shouldNotifyFocusableAvailable = canTakeFocus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="焦点事件的产生"><a href="#焦点事件的产生" class="headerlink" title="焦点事件的产生"></a>焦点事件的产生</h2><h3 id="第一次由系统产生焦点"><a href="#第一次由系统产生焦点" class="headerlink" title="第一次由系统产生焦点"></a>第一次由系统产生焦点</h3><p>当系统第一次调用到<code>ViewRootImpl.performTraversals()</code>方法时，会创建第一个焦点事件。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">    <span class="comment">// 当系统版本小于28时，sAlwaysAssignFocus为true</span></span><br><span class="line">    <span class="keyword">if</span> (sAlwaysAssignFocus || !isInTouchMode()) &#123;</span><br><span class="line">        <span class="comment">// handle first focus request</span></span><br><span class="line">        <span class="comment">// mView 为 DecorView</span></span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mView.hasFocus()) &#123;</span><br><span class="line">                <span class="comment">// 将焦点产生在DecorView上</span></span><br><span class="line">                mView.restoreDefaultFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Some views (like ScrollView) won&#x27;t hand focus to descendants that aren&#x27;t within</span></span><br><span class="line">        <span class="comment">// their viewport. Before layout, there&#x27;s a good change these views are size 0</span></span><br><span class="line">        <span class="comment">// which means no children can get focus. After layout, this view now has size, but</span></span><br><span class="line">        <span class="comment">// is not guaranteed to hand-off focus to a focusable child (specifically, the edge-</span></span><br><span class="line">        <span class="comment">// case where the child has a size prior to layout and thus won&#x27;t trigger</span></span><br><span class="line">        <span class="comment">// focusableViewAvailable).</span></span><br><span class="line">        <span class="comment">// 确保ScrollView等滑动View的子View会正确的获取到焦点</span></span><br><span class="line">        View focused = mView.findFocus();</span><br><span class="line">        <span class="keyword">if</span> (focused <span class="keyword">instanceof</span> ViewGroup </span><br><span class="line">                &amp;&amp; ((ViewGroup) focused).getDescendantFocusability() </span><br><span class="line">                == ViewGroup.FOCUS_AFTER_DESCENDANTS) &#123;</span><br><span class="line">            focused.restoreDefaultFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当系统第一次绘制时，会根据<code>sAlwaysAssignFocus</code>和当前是否为触摸模式进行判断是否产生焦点。<br><code>sAlwaysAssignFocus</code>会在<code>ViewRootImpl</code>初始化时根据当前版本是否小于Android9被赋值。而其中的<code>mView</code>为添加到Window的<code>DecorView</code>，所以系统第一次产生的焦点默认会产生在根View上，由根View调用<code>restoreDefaultFocus</code>在自己的子view中寻找合适和View，一般为左上角或右下角，由系统页面方向决定。而<code>restoreDefaultFocus</code>本质上就是调用了<code>requestFocus</code>方法。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restoreDefaultFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Android9前，打开一个包含EditView的Activity时EditView会自动获取焦点，导致软键盘弹出。可通过在父View上配置focusableInTouchMode &#x3D; true来消除此现象。</p></blockquote><blockquote><p>应用一般默认处于触摸模式下，当接收到遥控器或其他设备产生的KeyEvent，会切换到非触摸模式下</p></blockquote><h3 id="按键产生焦点"><a href="#按键产生焦点" class="headerlink" title="按键产生焦点"></a>按键产生焦点</h3><p>当第一次系统处于触摸模式或其他原因导致未产生第一个焦点，那么在按下任意一个按键将产生第一个焦点。</p><p>按下键后经由驱动层一步一步调用到Java层的入口<code>InputEventReceiver</code>方法，再逐步调用到<code>ViewRootImpl</code>的内部类<code>ViewPostImeInputStage.processKeyEvent()</code>方法中。该方法负责了按键事件的分发。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> KeyEvent event = (KeyEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUnhandledKeyManager.preViewDispatch(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deliver the key to the view hierarchy.</span></span><br><span class="line">    <span class="comment">// 在视图树上依次分发，判断焦点View是否自行处理KeyEvent，</span></span><br><span class="line">    <span class="comment">// 如果自定义key事件并返回true，后续不再执行</span></span><br><span class="line">    <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一些保护措施</span></span><br><span class="line">    <span class="comment">//在View层次结构不消费事件，判断窗口是否有输入事件或者已经停止和销毁</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This dispatch is for windows that don&#x27;t have a Window.Callback. Otherwise,</span></span><br><span class="line">    <span class="comment">// the Window.Callback usually will have already called this (see</span></span><br><span class="line">    <span class="comment">// DecorView.superDispatchKeyEvent) leaving this call a no-op.</span></span><br><span class="line">    <span class="keyword">if</span> (mUnhandledKeyManager.dispatch(mView, event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groupNavigationDirection = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断是否是前进后退组合键，决定焦点的移动方向</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_TAB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON)) &#123;</span><br><span class="line">            groupNavigationDirection = View.FOCUS_FORWARD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyEvent.metaStateHasModifiers(event.getMetaState(),</span><br><span class="line">                KeyEvent.META_META_ON | KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">            groupNavigationDirection = View.FOCUS_BACKWARD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a modifier is held, try to interpret the key as a shortcut.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; !KeyEvent.metaStateHasNoModifiers(event.getMetaState())</span><br><span class="line">            &amp;&amp; event.getRepeatCount() == <span class="number">0</span></span><br><span class="line">            &amp;&amp; !KeyEvent.isModifierKey(event.getKeyCode())</span><br><span class="line">            &amp;&amp; groupNavigationDirection == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 对快捷键进行处理，目前子View只有TextView进行了实现。</span></span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchKeyShortcutEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply the fallback event policy.</span></span><br><span class="line">    <span class="keyword">if</span> (mFallbackEventHandler.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle automatic focus changes.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (groupNavigationDirection != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行组合键策略</span></span><br><span class="line">            <span class="keyword">if</span> (performKeyboardGroupNavigation(groupNavigationDirection)) &#123;</span><br><span class="line">                <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行上下左右键策略</span></span><br><span class="line">            <span class="keyword">if</span> (performFocusNavigation(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户没有自定义KeyEvent处理事件，则会进行系统的焦点处理机制，在之前没有焦点时，会产生第一个焦点，而如果已经有了焦点，则会根据按键的类型进行焦点的移动。</p><p>会根据是按了前进后退键还是上下左右键调用<code>performKeyboardGroupNavigation(direction)</code>或<code>performFocusNavigation(keyEvent)</code>,而其内部通过调用<code>mView.restoreDefaultFocus()</code>进行产生焦点。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下前进后退键</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performKeyboardGroupNavigation</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View focused = mView.findFocus();</span><br><span class="line">    <span class="keyword">if</span> (focused == <span class="keyword">null</span> &amp;&amp; mView.restoreDefaultFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ..省略移动焦点代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下上下左右键</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performFocusNavigation</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// .. 省略判断方向代码</span></span><br><span class="line">    <span class="keyword">if</span> (direction != <span class="number">0</span>) &#123;</span><br><span class="line">        View focused = mView.findFocus();</span><br><span class="line">        <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// .. 省略移动代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView.restoreDefaultFocus()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>performKeyboardGroupNavigation</code>与<code>performFocusNavigation</code>完整代码分析见焦点的移动</p></blockquote><h3 id="requestFocus-请求焦点"><a href="#requestFocus-请求焦点" class="headerlink" title="requestFocus() 请求焦点"></a>requestFocus() 请求焦点</h3><p>在View中，<code>requestFocus</code>最终是调用了<code>requestFocusNoSearch</code></p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requestFocusNoSearch</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need to be focusable</span></span><br><span class="line">    <span class="comment">// 检测view可见性、layout空间大小等</span></span><br><span class="line">    <span class="keyword">if</span> (!canTakeFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need to be focusable in touch mode if in touch mode</span></span><br><span class="line">    <span class="comment">// 判断当前是否为触摸模式与是否配置了focusableInTouchMode = true</span></span><br><span class="line">    <span class="keyword">if</span> (isInTouchMode() &amp;&amp;</span><br><span class="line">        (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need to not have any parents blocking us</span></span><br><span class="line">    <span class="comment">// 判断是否有父View拦截焦点事件</span></span><br><span class="line">    <span class="keyword">if</span> (hasAncestorThatBlocksDescendantFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isLayoutValid()) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_WANTS_FOCUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearParentsWantFocus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理焦点事件</span></span><br><span class="line">    handleFocusGainInternal(direction, previouslyFocusedRect);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>requestFocusNoSearch</code>先通过一系列方法检测该View是否可以获得焦点，最后使用<code>handleFocusGainInternal</code>处理焦点事件。</p><blockquote><p>这里判断了focusableInTouchMode的值，所以当为触摸模式的时候，通过focusableInTouchMode&#x3D;true也可以使得View获取到焦点，所以大多数文章中使用通过在RecycleView或EditView等自动获取焦点的View的父View上配置这个属性来禁止RecycleView、EditView等自动获取焦点，因为这样可以使父View消耗掉这个焦点事件。</p></blockquote><p>在ViewGroup中，requestFocus有所不同。</p><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取配置的descendantFocusability</span></span><br><span class="line">    <span class="keyword">int</span> descendantFocusability = getDescendantFocusability();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (descendantFocusability) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> FOCUS_BLOCK_DESCENDANTS:</span><br><span class="line">            <span class="comment">// 直接请求自己的requestFocus</span></span><br><span class="line">            result = <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FOCUS_BEFORE_DESCENDANTS: &#123;</span><br><span class="line">            <span class="comment">// 1. 先自行进行请求焦点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> took = <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="comment">// 2. 如果自己不获取焦点，那么就通过onRequestFocusInDescendants方法分发到子View上</span></span><br><span class="line">            result = took ? took : onRequestFocusInDescendants(direction,</span><br><span class="line">                    previouslyFocusedRect);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> FOCUS_AFTER_DESCENDANTS: &#123;</span><br><span class="line">            <span class="comment">// 1. 先通过onRequestFocusInDescendants尝试分发给子View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> took = onRequestFocusInDescendants(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="comment">// 2. 如果子view不获取焦点，那么自己请求焦点</span></span><br><span class="line">            result = took ? took : <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;descendant focusability must be &quot;</span></span><br><span class="line">                    + <span class="string">&quot;one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but is &quot;</span> + descendantFocusability);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; !isLayoutValid() &amp;&amp; ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) == <span class="number">0</span>)) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_WANTS_FOCUS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewGroup中，判断了自身配置的<code>descendantFocusability</code>的值，其各自所代表的含义为：</p><ul><li><p><strong>FOCUS_BLOCK_DESCENDANTS</strong> ：<br>仅尝试将焦点分发给当前 ViewGroup</p></li><li><p><strong>FOCUS_BEFORE_DESCENDANTS</strong> ：<br>先尝试将焦点分发给当前 ViewGroup，然后才尝试将焦点分发给ChildView。</p></li><li><p><strong>FOCUS_AFTER_DESCENDANTS</strong> ：<br>先尝试将焦点分发给ChildView，然后才尝试将焦点分发给当前 ViewGroup。</p></li></ul><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleFocusGainInternal</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FOCUSED) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 更改焦点标志位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_FOCUSED;</span><br><span class="line">        <span class="comment">// 获取当前已经聚焦的View，用于在监听回调处理相应的逻辑</span></span><br><span class="line">        View oldFocus = (mAttachInfo != <span class="keyword">null</span>) ? getRootView().findFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通知 mParent 焦点变化事件</span></span><br><span class="line">            mParent.requestChildFocus(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">            updateFocusedInCluster(oldFocus, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通知 ViewTreeObserver 焦点变化事件</span></span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知当前View焦点变化事件，回调焦点变化监听</span></span><br><span class="line">        onFocusChanged(<span class="keyword">true</span>, direction, previouslyFocusedRect);</span><br><span class="line">        <span class="comment">// 刷新当前View的状态</span></span><br><span class="line">        refreshDrawableState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>handleFocusGainInternal</code>方法中，将本View标志位已改为了聚焦的状态，，并通知了一系列监听的变化及状态的改变，但在整个视图树中ViewGroup中存储的<code>mFocues</code>对象的值还并没有修改，该值将会在<code>requestChildFocus</code>方法中进行修改。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestChildFocus</span><span class="params">(View child, View focused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拦截了ChildView的获焦事件，此时焦点不需要继续向上一层级透传</span></span><br><span class="line">        <span class="keyword">if</span> (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unfocus us, if necessary</span></span><br><span class="line">        <span class="comment">// 主要作用为如果当前ViewGroup为焦点View，那么清除当前 ViewGroup 的焦点</span></span><br><span class="line">        <span class="keyword">super</span>.unFocus(focused);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We had a previous notion of who had focus. Clear it.</span></span><br><span class="line">        <span class="keyword">if</span> (mFocused != child) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFocused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 清除当前存储的View的焦点状态</span></span><br><span class="line">                mFocused.unFocus(focused);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更改存储的聚焦的view</span></span><br><span class="line">            mFocused = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里一层一层向上通知焦点View的改变</span></span><br><span class="line">            mParent.requestChildFocus(<span class="keyword">this</span>, focused);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>unFocus</p><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unFocus</span><span class="params">(View focused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果自身是聚焦View，那么清除自身</span></span><br><span class="line">    <span class="keyword">if</span> (mFocused == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.unFocus(focused);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFocused.unFocus(focused);</span><br><span class="line">        mFocused = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unFocus</span><span class="params">(View focused)</span> </span>&#123;</span><br><span class="line">    clearFocusInternal(focused, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearFocusInternal</span><span class="params">(View focused, <span class="keyword">boolean</span> propagate, <span class="keyword">boolean</span> refocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 清除标志位</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FOCUSED;</span><br><span class="line">        clearParentsWantFocus();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果propagate为true，则会向上层层调用清除mFocus的值</span></span><br><span class="line">        <span class="comment">// 调用unFocus时为false，调用clearFocus时为true</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &amp;&amp; mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.clearChildFocus(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知监听</span></span><br><span class="line">        onFocusChanged(<span class="keyword">false</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        refreshDrawableState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propagate &amp;&amp; (!refocus || !rootViewRequestFocus())) &#123;</span><br><span class="line">            notifyGlobalFocusCleared(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实此处传入的focused并没有实际作用。</p><h2 id="焦点的移动"><a href="#焦点的移动" class="headerlink" title="焦点的移动"></a>焦点的移动</h2><p>焦点的移动总的来说可以分为这几步。</p><ol><li>确定移动方向</li><li>寻找到当前具有焦点View</li><li>寻找到需要接受焦点的View</li><li>切换View的状态</li></ol><h3 id="组合键焦点移动"><a href="#组合键焦点移动" class="headerlink" title="组合键焦点移动"></a>组合键焦点移动</h3><p>在前进后退组合键触发的焦点移动中，移动方向已经在<code>processKeyEvent</code>中确定。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performKeyboardGroupNavigation</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 通过findFocus方法找到当前具有焦点的View，如果当前没有View获取焦点则返回null</span></span><br><span class="line">    <span class="comment">//    产生一个默认的焦点</span></span><br><span class="line">    <span class="keyword">final</span> View focused = mView.findFocus();</span><br><span class="line">    <span class="keyword">if</span> (focused == <span class="keyword">null</span> &amp;&amp; mView.restoreDefaultFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 寻找需要接受焦点的View</span></span><br><span class="line">    View cluster = focused == <span class="keyword">null</span> ? keyboardNavigationClusterSearch(<span class="keyword">null</span>, direction)</span><br><span class="line">                : focused.keyboardNavigationClusterSearch(<span class="keyword">null</span>, direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since requestFocus only takes &quot;real&quot; focus directions (and therefore also</span></span><br><span class="line">    <span class="comment">// restoreFocusInCluster), convert forward/backward focus into FOCUS_DOWN.</span></span><br><span class="line">    <span class="keyword">int</span> realDirection = direction;</span><br><span class="line">    <span class="keyword">if</span> (direction == View.FOCUS_FORWARD || direction == View.FOCUS_BACKWARD) &#123;</span><br><span class="line">        realDirection = View.FOCUS_DOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 通过调用restoreFocusNotInCluster restoreFocusInCluster切换焦点</span></span><br><span class="line">    <span class="keyword">if</span> (cluster != <span class="keyword">null</span> &amp;&amp; cluster.isRootNamespace()) &#123;</span><br><span class="line">        <span class="comment">// the default cluster. Try to find a non-clustered view to focus.</span></span><br><span class="line">        <span class="keyword">if</span> (cluster.restoreFocusNotInCluster()) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise skip to next actual cluster</span></span><br><span class="line">        cluster = keyboardNavigationClusterSearch(<span class="keyword">null</span>, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cluster != <span class="keyword">null</span> &amp;&amp; cluster.restoreFocusInCluster(realDirection)) &#123;</span><br><span class="line">        <span class="comment">// 播发按键音</span></span><br><span class="line">        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用了<code>View.findFocus</code>方法开始查找焦点View。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_FOCUSED) != <span class="number">0</span> ? <span class="keyword">this</span> : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFocused()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mFocused是具有焦点的View</span></span><br><span class="line">    <span class="keyword">if</span> (mFocused != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFocused.findFocus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在View中，和<code>hasFocus</code>方法一样，是通过判断标识位来判断是否具有焦点。而在ViewGroup，如果自身具有焦点直接返回自己，如果是子View中具有焦点则通过递归调用<code>mFocused.findFocus</code>直到找到焦点View。</p><p>当查询到焦点View后通过<code>View.keyboardNavigationClusterSearch</code>或<code>ViewRootImpl.keyboardNavigationClusterSearch</code>进行查找目标焦点View。而View与ViewRootImpl都是会将搜寻工作代理给<code>FocusFinder</code>类，但在View中，会进行判断是否为根View，也就是是否为DecorView。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">keyboardNavigationClusterSearch</span><span class="params">(View currentCluster,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@FocusDirection</span> <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isKeyboardNavigationCluster()) &#123;</span><br><span class="line">            currentCluster = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRootNamespace()) &#123;</span><br><span class="line">            <span class="comment">// Root namespace means we should consider ourselves the top of the</span></span><br><span class="line">            <span class="comment">// tree for group searching; otherwise we could be group searching</span></span><br><span class="line">            <span class="comment">// into other tabs.  see LocalActivityManager and TabHost for more info.</span></span><br><span class="line">            <span class="comment">// 如果是根View，则代理给FocusFinder负责进行搜寻工作</span></span><br><span class="line">            <span class="keyword">return</span> FocusFinder.getInstance().findNextKeyboardNavigationCluster(</span><br><span class="line">                    <span class="keyword">this</span>, currentCluster, direction);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 一层一层向上找根View</span></span><br><span class="line">            <span class="keyword">return</span> mParent.keyboardNavigationClusterSearch(currentCluster, direction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">keyboardNavigationClusterSearch</span><span class="params">(View currentCluster,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@FocusDirection</span> <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="comment">// 代理到FocusFinder</span></span><br><span class="line">        <span class="keyword">return</span> FocusFinder.getInstance().findNextKeyboardNavigationCluster(</span><br><span class="line">                mView, currentCluster, direction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在确定目标View后，通过调用<code>View.restoreFocusNotInCluster</code>与<code> View.restoreFocusInCluster</code>切换焦点,内部均是通过调用了<code>requestFocus()</code>实现了焦点的切换</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restoreFocusInCluster</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prioritize focusableByDefault over algorithmic focus selection.</span></span><br><span class="line">    <span class="keyword">if</span> (restoreDefaultFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(direction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restoreDefaultFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restoreFocusNotInCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过方向键焦点移动"><a href="#通过方向键焦点移动" class="headerlink" title="通过方向键焦点移动"></a>通过方向键焦点移动</h3><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performFocusNavigation</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> direction = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 根据按键确定方向</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_RIGHT:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_UP:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_UP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_DOWN:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_FORWARD;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                direction = View.FOCUS_BACKWARD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (direction != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 找到当前聚焦的View</span></span><br><span class="line">        View focused = mView.findFocus();</span><br><span class="line">        <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 寻找需要获取焦点的View</span></span><br><span class="line">            View v = focused.focusSearch(direction);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != focused) &#123;</span><br><span class="line">                <span class="comment">// do the math the get the interesting rect</span></span><br><span class="line">                <span class="comment">// of previous focused into the coord system of</span></span><br><span class="line">                <span class="comment">// newly focused view</span></span><br><span class="line">                focused.getFocusedRect(mTempRect);</span><br><span class="line">                <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                    ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                                focused, mTempRect);</span><br><span class="line">                    ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                                v, mTempRect);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4. 进行焦点状态的切换</span></span><br><span class="line">                <span class="keyword">if</span> (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                    playSoundEffect(SoundEffectConstants</span><br><span class="line">                                .getContantForFocusDirection(direction));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Give the focused view a last chance to handle the dpad key.</span></span><br><span class="line">            <span class="keyword">if</span> (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当没有焦点时产生默认的焦点</span></span><br><span class="line">            <span class="keyword">if</span> (mView.restoreDefaultFocus()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会通过用户实际按下的按键判断当前需要向哪个方向进行搜寻，然后也是通过调用<code>mView.findFocus()</code>找到当前聚焦的View，与组合键操作不同的是，方向键查找下一个是调用的是<code>View.focusSearch(direction)</code>，不过，这个方法内部也是将具体的搜寻工作代理到了<code>FocusFinder</code>这个类上。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">focusSearch</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mParent.focusSearch(<span class="keyword">this</span>, direction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">focusSearch</span><span class="params">(View focused, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRootNamespace()) &#123;</span><br><span class="line">        <span class="comment">// root namespace means we should consider ourselves the top of the</span></span><br><span class="line">        <span class="comment">// tree for focus searching; otherwise we could be focus searching</span></span><br><span class="line">        <span class="comment">// into other tabs.  see LocalActivityManager and TabHost for more info.</span></span><br><span class="line">        <span class="keyword">return</span> FocusFinder.getInstance().findNextFocus(<span class="keyword">this</span>, focused, direction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mParent.focusSearch(focused, direction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FocusFinder查找的具体实现"><a href="#FocusFinder查找的具体实现" class="headerlink" title="FocusFinder查找的具体实现"></a>FocusFinder查找的具体实现</h4><p>但现在先暂时跳过探究<code>FocusFinder</code>如何找到目标View，先来关注下<code>requestFocus</code>这个方法中是如何进行焦点切换工作的。<strong>1问题：为什么当前ViewGourp内找不到适合的焦点View话会找到更高级的ViewGroup里的View（可能在添加备选列表时将所有父View符合的View添加到了列表中）</strong> </p><h2 id="清除焦点"><a href="#清除焦点" class="headerlink" title="清除焦点"></a>清除焦点</h2><h3 id="清除焦点的方法"><a href="#清除焦点的方法" class="headerlink" title="清除焦点的方法"></a>清除焦点的方法</h3><p>当手动调用clearFocus方法或使获焦的 View 被移除(隐藏不可见)的时候，会进行焦点的清除工作。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/* Check if the GONE bit has changed */</span></span><br><span class="line">    <span class="keyword">if</span> ((changed &amp; GONE) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((mViewFlags &amp; VISIBILITY_MASK) == GONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasFocus()) &#123;</span><br><span class="line">              <span class="comment">// 进行清除焦点</span></span><br><span class="line">                clearFocus();</span><br><span class="line">                <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                    ((ViewGroup) mParent).clearFocusedInCluster();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            clearAccessibilityFocus();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ViewGourp.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeDetachedView</span><span class="params">(View child, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child == mFocused) &#123;</span><br><span class="line">            child.clearFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    clearFocusInternal(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="焦点的重分配（矫正焦点）"><a href="#焦点的重分配（矫正焦点）" class="headerlink" title="焦点的重分配（矫正焦点）"></a>焦点的重分配（矫正焦点）</h3><p>当某个View从Gone转变为Visible，或在一个聚焦的父View中的子View可获焦了，焦点需要重新分配到正确的位置上。</p><figure class="highlight java"><figcaption><span>View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newVisibility = flags &amp; VISIBILITY_MASK;</span><br><span class="line">    <span class="keyword">if</span> (newVisibility == VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((changed &amp; VISIBILITY_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If this view is becoming visible, invalidate it in case it changed while</span></span><br><span class="line"><span class="comment">             * it was not visible. Marking it drawn ensures that the invalidation will</span></span><br><span class="line"><span class="comment">             * go through.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            needGlobalAttributesUpdate(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a view becoming visible is worth notifying the parent about in case nothing has</span></span><br><span class="line">            <span class="comment">// focus. Even if this specific view isn&#x27;t focusable, it may contain something that</span></span><br><span class="line">            <span class="comment">// is, so let the root view try to give this focus if nothing else does.</span></span><br><span class="line">            <span class="comment">// 判断是否可需要通知矫正焦点1</span></span><br><span class="line">            shouldNotifyFocusableAvailable = hasSize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((changed &amp; ENABLED_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED) &#123;</span><br><span class="line">            <span class="comment">// a view becoming enabled should notify the parent as long as the view is also</span></span><br><span class="line">            <span class="comment">// visible and the parent wasn&#x27;t already notified by becoming visible during this</span></span><br><span class="line">            <span class="comment">// setFlags invocation.</span></span><br><span class="line">            <span class="comment">// 判断是否可需要通知矫正焦点2</span></span><br><span class="line">            shouldNotifyFocusableAvailable = canTakeFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFocused()) clearFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldNotifyFocusableAvailable &amp;&amp; mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通知父View需要进行焦点重分配，最终会被ViewRootImpl接收</span></span><br><span class="line">        mParent.focusableViewAvailable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focusableViewAvailable</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span></span><br><span class="line">            <span class="comment">// shortcut: don&#x27;t report a new focusable view if we block our descendants from</span></span><br><span class="line">            <span class="comment">// getting focus or if we&#x27;re not visible</span></span><br><span class="line">            &amp;&amp; (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS)</span><br><span class="line">            &amp;&amp; ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE)</span><br><span class="line">            &amp;&amp; (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen())</span><br><span class="line">            <span class="comment">// shortcut: don&#x27;t report a new focusable view if we already are focused</span></span><br><span class="line">            <span class="comment">// (and we don&#x27;t prefer our descendants)</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// note: knowing that mFocused is non-null is not a good enough reason</span></span><br><span class="line">            <span class="comment">// to break the traversal since in that case we&#x27;d actually have to find</span></span><br><span class="line">            <span class="comment">// the focused view and make sure it wasn&#x27;t FOCUS_AFTER_DESCENDANTS and</span></span><br><span class="line">            <span class="comment">// an ancestor of v; this will get checked for at ViewAncestor</span></span><br><span class="line">            &amp;&amp; !(isFocused() &amp;&amp; getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) &#123;</span><br><span class="line">        <span class="comment">// 一层一层向上传递</span></span><br><span class="line">        mParent.focusableViewAvailable(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在一层一层向上传递后，最终会传递到<code>ViewRootImpl</code>中进行具体焦点的分配工作。</p><figure class="highlight java"><figcaption><span>ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focusableViewAvailable</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mView.hasFocus()) &#123;</span><br><span class="line">            <span class="comment">// 如果视图树中没有一个View有焦点，则直接在传递来的View上获取焦点</span></span><br><span class="line">            <span class="keyword">if</span> (sAlwaysAssignFocus || !mAttachInfo.mInTouchMode) &#123;</span><br><span class="line">                v.requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// the one case where will transfer focus away from the current one</span></span><br><span class="line">            <span class="comment">// is if the current view is a view group that prefers to give focus</span></span><br><span class="line">            <span class="comment">// to its children first AND the view is a descendant of it.</span></span><br><span class="line">            <span class="comment">// 如果当前有焦点View</span></span><br><span class="line">            View focused = mView.findFocus();</span><br><span class="line">            <span class="comment">// 检查是否需要将焦点转移到这个View上</span></span><br><span class="line">            <span class="keyword">if</span> (focused <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                ViewGroup group = (ViewGroup) focused;</span><br><span class="line">                <span class="comment">// 如果当前焦点View是传递来的View的直接父View，</span></span><br><span class="line">                <span class="comment">// 并且焦点优先子获取View，则将焦点传递给v</span></span><br><span class="line">                <span class="keyword">if</span> (group.getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS</span><br><span class="line">                        &amp;&amp; isViewDescendantOf(v, focused)) &#123;</span><br><span class="line">                    v.requestFocus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以转移规则为：</p><ul><li><p>如果当前视图树中不存在焦点，则直接尝试将焦点分发给这个可获焦的 View</p></li><li><p>如果存在焦点，则检查焦点View为直系父View，并配置了<code>FOCUS_AFTER_DESCENDANTS</code>,是否需要将焦点转移到这个可获焦的 View</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p>[1] <a href="https://juejin.cn/post/6871541574019317768">Android焦点分发过程解析 - 薛定谔的程序猫</a></p></li><li><p>[2] <a href="https://juejin.cn/post/6871542178506604551">Android焦点搜索过程解析 - 薛定谔的程序猫</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android的TouchMode</title>
      <link href="/2021/03/30/Android%E7%9A%84TouchMode/"/>
      <url>/2021/03/30/Android%E7%9A%84TouchMode/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是TouchMode"><a href="#什么是TouchMode" class="headerlink" title="什么是TouchMode"></a>什么是TouchMode</h2><p>TouchMode就是”触摸模式“。在一般情况下，Android系统都是处于TouchMode的模式下也就是<code>View.isInTouchMode() == true</code>的状态下。大多Android开发都是开发的手机App应用，所以可能没有接触或使用过TouchMode，而在开发Android TV应用或其他没有触摸屏的应用时会接触到这个TouchMode，但一旦使用遥控器遥控或调用了<code>View.requestFocusFromTouch</code>等可以更改TouchMode的方法后，系统就会退出TouchMode，当用户点击屏幕后，就会进入触屏模式也就是TouchMode模式。</p><span id="more"></span><h2 id="TouchMode的影响"><a href="#TouchMode的影响" class="headerlink" title="TouchMode的影响"></a>TouchMode的影响</h2><p>是否处于TouchMode会对控件的焦点（focus）产生影响。</p><p>当处于TouchMode时，直接请求<code>requestFocus()</code>是无效的，因为<code>requestFocus()</code>会最终调用到<code>View.requestFocusNoSearch()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requestFocusNoSearch</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// need to be focusable in touch mode if in touch mode</span></span><br><span class="line">    <span class="keyword">if</span> (isInTouchMode() &amp;&amp;</span><br><span class="line">              (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>而其内部进行判断了<code>isInTouchMode()</code>,当处于触摸模式下，会直接返回false，导致请求焦点失败。</p><p><strong>在这个模式下，大多是View是无法获取到焦点的，如果你在开发TV应用时，发现每当开机后，焦点不能准确的选中设定的那一个，那么就需要检查下你的TouchMode与是否使用了<code>requestFocus()</code>进行请求焦点。</strong></p><p>像一些EditView等一些特殊的View，是可以下TouchMode下获取到焦点的，因为这些View的isFocusableInTouchMode()为true，其他的View被点击时不会获得焦点，只是会触发<code>onClick()</code></p><h2 id="如何更改TouchMode"><a href="#如何更改TouchMode" class="headerlink" title="如何更改TouchMode"></a>如何更改TouchMode</h2><ul><li>退出TouchMode</li></ul><p>直接调用<code>View.requestFocusFromTouch()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View.requestFocusFromTouch</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestFocusFromTouch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Leave touch mode if we need to</span></span><br><span class="line">      <span class="keyword">if</span> (isInTouchMode()) &#123;</span><br><span class="line">          ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">          <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 此处就是将TouchMode设置为false</span></span><br><span class="line">              viewRoot.ensureTouchMode(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ViewRootImpl.ensureTouchMode</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">ensureTouchMode</span><span class="params">(<span class="keyword">boolean</span> inTouchMode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (DBG) Log.d(<span class="string">&quot;touchmode&quot;</span>, <span class="string">&quot;ensureTouchMode(&quot;</span> + inTouchMode + <span class="string">&quot;), current &quot;</span></span><br><span class="line">              + <span class="string">&quot;touch mode is &quot;</span> + mAttachInfo.mInTouchMode);</span><br><span class="line">      <span class="keyword">if</span> (mAttachInfo.mInTouchMode == inTouchMode) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// tell the window manager</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 此处真正设置TouchMode，而mWindowSession是一个全局的单例对象，</span></span><br><span class="line">      <span class="comment">// 故设置后TouchMode是可以整个应用内生效的</span></span><br><span class="line">          mWindowSession.setInTouchMode(inTouchMode);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// handle the change</span></span><br><span class="line">      <span class="keyword">return</span> ensureTouchModeLocally(inTouchMode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>进入TouchMode</li></ul><p>随意点击或滑动即可进入TouchMode模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enter touch mode on down or scroll, if it is coming from a touch screen device,</span></span><br><span class="line"><span class="comment">// exit otherwise.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"><span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_SCROLL) &#123;</span><br><span class="line">    ensureTouchMode(event.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> View体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity2019与Android混合开发</title>
      <link href="/2021/03/26/Unity2019%E4%B8%8EAndroid%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
      <url>/2021/03/26/Unity2019%E4%B8%8EAndroid%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="0-开始前的版本对齐"><a href="#0-开始前的版本对齐" class="headerlink" title="0. 开始前的版本对齐"></a>0. 开始前的版本对齐</h2><p>Unity版本：Unity2019.3.4f1<br>AndroidStudio版本：3.5.3</p><h2 id="1-Unity-–-准备项目"><a href="#1-Unity-–-准备项目" class="headerlink" title="1. Unity – 准备项目"></a>1. Unity – 准备项目</h2><ol><li><p>新建项目</p></li><li><p>打开File -&gt; Build Setting</p><span id="more"></span><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-688b0c5fc16f42e6.png" alt="File -&gt; Build Setting"></p></li><li><p>切换工程模式<br>首先选择Android Platform，然后点击Switch Platform切换工程模式。</p></li></ol><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-7aebd02c3551f8ad.png" alt="切换工程模式"></p><ol start="4"><li>导出Android工程<br>先<strong>勾上Export Project</strong>，否则下方的Export按钮会是一个Build，点击后Unity会直接导出一个Apk文件，而并不是一个Android Studio项目。<br>点击Export后，选择保存位置后会成功输出一个Android Studio项目，此时Unity的操作告一段落。</li></ol><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-9ecfea6bf0514e82.png" alt="导出工程"></p><h2 id="2-Android-打开项目"><a href="#2-Android-打开项目" class="headerlink" title="2. Android 打开项目"></a>2. Android 打开项目</h2><p>在使用Android studio 打开项目时，会跳出一个选择SDK的选项，此处我选择使用Android Studio’s SDK。<em>Project’s SDK是Unity提供的，我觉得用此SDK可能对原生开发会有一定的影响。我并没有使用Project’s SDK进行验证。</em></p><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-acb239b463c8eabc.png" alt="sdk 选择"></p><p>然后在弹出的Gradle 同步提示框中点击OK后项目就开始同步，如果无错误就可以进行开发了</p><h2 id="3-Android-项目结构"><a href="#3-Android-项目结构" class="headerlink" title="3. Android 项目结构"></a>3. Android 项目结构</h2><p>Gradle同步完成后，可以看到以下目录（从Android视图切换为了Project）</p><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-fc63145d42e1f91c.png" alt="项目列表"></p><p>其中<code>launcher</code>为平时Android开发中app主module，推荐在launcher主module中开发新的逻辑。（java目录需要自行创建）。</p><p><code>unityLibrary</code>为Unity生成的子module。<br>在unityLibrary中包含一个<code>UnityPlayerActivity</code>的示例<code>Activity</code>，在不进行修改任何代码的时候默认启动的<code>Activity</code>就是这个<code>UnityPlayerActivity</code>。(可以在AndroidManifest中看到将这个activity配置成了启动Acitivity)</p><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-1af797cc571035e2.png" alt="image.png"></p><p>而在<code>unityLibrary</code> module中的lib目录中可以看到有一个<code>unity-classes.jar</code>，一个非常重要的类<code>UnityPlayer</code>就是来自这个jar包。<strong>如果之前已经在Unity项目中添加过一些Android插件，在lib目录下也会出现这些其他的lib包</strong>。</p><p>那么我们来看下<code>UnityPlayerActivity</code>这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAIN</span></span><br><span class="line"><span class="keyword">package</span> com.unity3d.player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.Window;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnityPlayerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">IUnityPlayerLifecycleEvents</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> UnityPlayer mUnityPlayer; <span class="comment">// don&#x27;t change the name of this variable; referenced from native code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override this in your custom UnityPlayerActivity to tweak the command line arguments passed to the Unity Android Player</span></span><br><span class="line">    <span class="comment">// The command line arguments are passed as a string, separated by spaces</span></span><br><span class="line">    <span class="comment">// UnityPlayerActivity calls this from &#x27;onCreate&#x27;</span></span><br><span class="line">    <span class="comment">// Supported: -force-gles20, -force-gles30, -force-gles31, -force-gles31aep, -force-gles32, -force-gles, -force-vulkan</span></span><br><span class="line">    <span class="comment">// See https://docs.unity3d.com/Manual/CommandLineArguments.html</span></span><br><span class="line">    <span class="comment">// @param cmdLine the current command line arguments, may be null</span></span><br><span class="line">    <span class="comment">// @return the modified command line string or null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">updateUnityCommandLineArguments</span><span class="params">(String cmdLine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cmdLine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup activity layout</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra(<span class="string">&quot;unity&quot;</span>));</span><br><span class="line">        getIntent().putExtra(<span class="string">&quot;unity&quot;</span>, cmdLine);</span><br><span class="line"></span><br><span class="line">        mUnityPlayer = <span class="keyword">new</span> UnityPlayer(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">        setContentView(mUnityPlayer);</span><br><span class="line">        mUnityPlayer.requestFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When Unity player unloaded move task to background</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnityPlayerUnloaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        moveTaskToBack(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When Unity player quited kill process</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnityPlayerQuitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Process.killProcess(Process.myPid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// To support deep linking, we need to make sure that the client can get access to</span></span><br><span class="line">        <span class="comment">// the last sent intent. The clients access this through a JNI api that allows them</span></span><br><span class="line">        <span class="comment">// to get the intent set on launch. To update that after launch we have to manually</span></span><br><span class="line">        <span class="comment">// replace the intent with the one caught here.</span></span><br><span class="line">        setIntent(intent);</span><br><span class="line">        mUnityPlayer.newIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mUnityPlayer.destroy();</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pause Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mUnityPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resume Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mUnityPlayer.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Low Memory Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLowMemory();</span><br><span class="line">        mUnityPlayer.lowMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trim Memory Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">        <span class="keyword">if</span> (level == TRIM_MEMORY_RUNNING_CRITICAL)</span><br><span class="line">        &#123;</span><br><span class="line">            mUnityPlayer.lowMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This ensures the layout will be correct.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">        mUnityPlayer.configurationChanged(newConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify Unity of the focus change.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">        mUnityPlayer.windowFocusChanged(hasFocus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For some reason the multiple keyevent type is not supported by the ndk.</span></span><br><span class="line">    <span class="comment">// Force event injection by overriding dispatchKeyEvent().</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_MULTIPLE)</span><br><span class="line">            <span class="keyword">return</span> mUnityPlayer.injectEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass any events not handled by (unfocused) views straight to UnityPlayer</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>     </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>   </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span>          </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="comment">/*API12*/</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onGenericMotionEvent</span><span class="params">(MotionEvent event)</span>  </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>UnityPlayer mUnityPlayer</code>就是Unity最终绘制内容的<code>View</code>（是一个<code>FrameLayout</code>），而<code>UnityPlayerActivity</code> 将这个View设置为自己的根<code>View</code>，进行显示。所以也可以自定义一个任意大小的布局，将<code>mUnityPlayer</code>当做正常的<code>View</code> 添加到布局中，进行自定义大小的控制。<br>而<code>UnityPlayerActivity</code> 也重写了<code>onResume</code>、<code>onPause</code>等进行了对<code>mUnityPlayer</code>生命周期的管理。</p><h2 id="4-Android与Unity跳转"><a href="#4-Android与Unity跳转" class="headerlink" title="4. Android与Unity跳转"></a>4. Android与Unity跳转</h2><p>一般情况下，混合开发都是会先启动原生界面，然后通过点击原生的中<code>button</code>根据业务逻辑跳转至包含Unity的<code>Activity</code>。这样我们就不能将<code>UnityPlayerActivity</code>设置为第一个启动的<code>Activity</code>。</p><ol><li>取消<code>UnityPlayerActivity</code>默认启动<br>在<code>AndroidManifest</code>文件中删除或注释掉<code>UnityPlayerActivity</code>配置的下<code>intent-filter</code><br><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/6267288-db51884ed9549f90.png" alt="删除intent-filter"><br><strong>小伙伴如果之前已经在Unity中导入了其他Android插件，那么这个<code>AndroidManifest</code>中显示的<code>Activity</code>应该是插件中自定义的<code>Activity</code>，而不是<code>UnityPlayerActivity</code>，注释掉相应的代码即可。</strong></li><li>页面跳转<br>通过常规的<code>startActivity</code>即可启动<code>UnityPlayerActivity</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn_button1).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(HomeActivity.<span class="keyword">this</span>, UnityPlayerActivity.class);</span><br><span class="line">                </span><br><span class="line">        startActivity(intent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>但是，当你finish到这个<code>UnityPlayerActivity</code>时你会发现，即使还有<code>Activity</code>显示，应用还是自动关闭了。这个问题是因为在<code>UnityPlayerActivity</code>中的<code>onDestroy</code>方法中调用了<code>mUnityPlayer</code>中<code>destroy</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quit Unity</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mUnityPlayer.destroy();</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>我们点进<code>mUnityPlayer.destroy()</code>看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略无用代码</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mProcessKillRequested) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.m_UnityPlayerLifecycleEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m_UnityPlayerLifecycleEvents.onUnityPlayerQuitted();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.onUnityPlayerQuitted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Process.killProcess(Process.myPid()); <span class="comment">// 结束自己的进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unloadNative();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现在<code>mProcessKillRequested </code>为<code>true</code>的时候，会进行一个杀自己进程的操作，而我们一般app都是一个进程，就会导致我们的app被kill掉。<br>解决办法就是在<code>AndroidManifest</code>配置一下<code>UnityPlayerActivity</code>，<code>UnityPlayerActivity</code>以一个新的进程启动。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:process=&quot;:e.unitry3d&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fanleiym/article/details/83894399">Android多进程总结一:生成多进程(android:process属性)</a></p><h2 id="5-Android-自定义Unity显示形式"><a href="#5-Android-自定义Unity显示形式" class="headerlink" title="5. Android 自定义Unity显示形式"></a>5. Android 自定义Unity显示形式</h2><p>由于业务的需求决定，混合开发中的<code>Unity</code>不一定为全屏幕显示或者可能需要多个Unity界面，那么就需要继承<code>UnityPlayerActivity</code>进行自定义一个显示Unity的界面。</p><p>当我们的业务需求决定了我们需要实现一个<code>UnityPlayerActivity</code>的子类进行扩展功能的时候，需要进行以下步骤：</p><ol><li><p>禁止<code>UnityPlayerActivity</code>中添加<code>mUnityPlayer</code><br>在<code>UnityPlayerActivity</code>的<code>onCreate</code>中注释<code>setContentView</code>和<code>requestFocus</code>代码,因为要在子类中按需加载<code>mUnityPlayer</code>，防止多次设置View，就注释掉父类的相关代码。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup activity layout</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra(<span class="string">&quot;unity&quot;</span>));</span><br><span class="line">    getIntent().putExtra(<span class="string">&quot;unity&quot;</span>, cmdLine);</span><br><span class="line"></span><br><span class="line">    mUnityPlayer = <span class="keyword">new</span> UnityPlayer(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//setContentView(mUnityPlayer);</span></span><br><span class="line">    <span class="comment">//mUnityPlayer.requestFocus();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>实现子类，将<code>mUnityPlayer</code>设置给布局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnityActivity</span> <span class="keyword">extends</span> <span class="title">UnityPlayerActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.layout_unity);</span><br><span class="line"></span><br><span class="line">        FrameLayout frameLayout = findViewById(R.id.framelayout);</span><br><span class="line">        frameLayout.addView(mUnityPlayer);</span><br><span class="line"></span><br><span class="line">        mUnityPlayer.requestFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    setContentView(mUnityPlayer);</span><br><span class="line">    mUnityPlayer.requestFocus();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个地方需要注意两点：1.如果之前导入过插件，这里一定要继承自插件中实现的UnityPlayerActivity子类，否则，插件的方法不会被调用。2. 记得要将实现的Activity配置为新的进程。</strong></p><p><em>如果想启动不同的Unity界面，也不需要实现多个Activity子类，和Unity开发约定下通信规则，确定好发送什么参数启动什么页面，在Activity启动后调用相关的方法，发送约定好的参数即可。</em></p><p>例如：<br>启动界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn_button1).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(HomeActivity.<span class="keyword">this</span>, UnityActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;panelName&quot;</span>,<span class="string">&quot;LunchPanel&quot;</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>UnityActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    setContentView(mUnityPlayer);</span><br><span class="line">    mUnityPlayer.requestFocus();</span><br><span class="line"></span><br><span class="line">    String panelName = getIntent().getStringExtra(<span class="string">&quot;panelName&quot;</span>);</span><br><span class="line"></span><br><span class="line">    UnityPlayer.UnitySendMessage(<span class="string">&quot;UIRoot&quot;</span>,<span class="string">&quot;openPanel&quot;</span>,panelName);<span class="comment">//unity方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用Fragment当做Unity显示的载体"><a href="#6-使用Fragment当做Unity显示的载体" class="headerlink" title="6. 使用Fragment当做Unity显示的载体"></a>6. 使用Fragment当做Unity显示的载体</h3><p>目前我试出来的方案就是将<code>mUnityPlayer</code>在<code>Fragment</code>将要挂载的<code>Activity</code>中进行创建并进行生命周期的管理。</p><p>Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> UnityPlayer mUnityPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.home_activity);</span><br><span class="line">        mUnityPlayer = <span class="keyword">new</span> UnityPlayer(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">        fragmentManager.beginTransaction().add(R.id.fl,<span class="keyword">new</span> UnityFragment(mUnityPlayer)).commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// To support deep linking, we need to make sure that the client can get access to</span></span><br><span class="line">        <span class="comment">// the last sent intent. The clients access this through a JNI api that allows them</span></span><br><span class="line">        <span class="comment">// to get the intent set on launch. To update that after launch we have to manually</span></span><br><span class="line">        <span class="comment">// replace the intent with the one caught here.</span></span><br><span class="line">        setIntent(intent);</span><br><span class="line">        mUnityPlayer.newIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quit Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mUnityPlayer.destroy();</span><br><span class="line">        <span class="comment">//mUnityPlayer.unloadNative();</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pause Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mUnityPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resume Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mUnityPlayer.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Low Memory Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLowMemory();</span><br><span class="line">        mUnityPlayer.lowMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trim Memory Unity</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">        <span class="keyword">if</span> (level == TRIM_MEMORY_RUNNING_CRITICAL)</span><br><span class="line">        &#123;</span><br><span class="line">            mUnityPlayer.lowMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This ensures the layout will be correct.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">        mUnityPlayer.configurationChanged(newConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify Unity of the focus change.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">        mUnityPlayer.windowFocusChanged(hasFocus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For some reason the multiple keyevent type is not supported by the ndk.</span></span><br><span class="line">    <span class="comment">// Force event injection by overriding dispatchKeyEvent().</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_MULTIPLE)</span><br><span class="line">            <span class="keyword">return</span> mUnityPlayer.injectEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass any events not handled by (unfocused) views straight to UnityPlayer</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>     </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>   </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span>          </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line">    <span class="comment">/*API12*/</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onGenericMotionEvent</span><span class="params">(MotionEvent event)</span>  </span>&#123; <span class="keyword">return</span> mUnityPlayer.injectEvent(event); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnityFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UnityPlayer mUnityPlayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnityFragment</span><span class="params">(UnityPlayer unityPlayer)</span> </span>&#123;</span><br><span class="line">        mUnityPlayer = unityPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mUnityPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Unity与Android之间的通讯"><a href="#7-Unity与Android之间的通讯" class="headerlink" title="7. Unity与Android之间的通讯"></a>7. Unity与Android之间的通讯</h2><p>此内容网络上已有较多文章，本文不再叙述。</p><h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h2><ol><li><strong>当Unity与Android同时开发时，每次从Unity导出新的项目覆盖之前的老代码的时候主launcher中的AndroidManifest文件会被重置，导出前务必要备份。</strong></li></ol><hr><p>文章可能因为个人能力原因出现错误，忘谅解。希望能够指出。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2021/03/26/JavaWeb%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/26/JavaWeb%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获取数据库连接对象</span></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://59.110.213.97:3306/test?useSSL=false&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>, <span class="string">&quot;GHn,.155070&quot;</span>);</span><br><span class="line"><span class="comment">//定义sql语句</span></span><br><span class="line">String sql = <span class="string">&quot; insert into table_test(id,number) values(null,10086)&quot;</span>;</span><br><span class="line"><span class="comment">//获取执行sql的对象</span></span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line"><span class="comment">//执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="常用类介绍"><a href="#常用类介绍" class="headerlink" title="常用类介绍"></a>常用类介绍</h3><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><p>驱动管理对象 </p><ul><li><p>注册驱动</p><p>  在<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>中有个静态代码块，使用了DriverManager进行注册驱动</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>在mysql5之后 可以不写class.forname进行加载，会自动进行加载</strong></p></li><li><p>获取数据库连接</p><p>  <code>static Connection getConnection(String url,String user, String password)</code></p><p>  url : <code>jdbc:mysql://ip地址:端口/数据库名称</code></p><p>  如果为本机数据库，而且端口为3306，可以简写为<code>jdbc:mysql:///数据库名称</code></p></li></ul><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>数据库连接对象 </p><ul><li>获取执行sql的对象(Statement&#x2F;PreparedStatement)<ol><li><code>Statement createStatement()</code></li><li><code>PreparedStatement preparedStatement(String sql)</code></li></ol></li><li>管理事务<ol><li>开始事务：<code>setAutiCommit(boolean autoCommit)</code></li><li>提交事务: <code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ol></li></ul><h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>静态sql(不设置站位数据)执行对象</p><ol><li><p><code>boolean execute(String sql)</code></p><p> 可以执行任意sql</p></li><li><p><code>int  executeUpdate(String sql)</code></p><p> 可以执行 增删改 和 创建修改删除 sql语句，返回受影响的行数</p></li><li><p><code>ResultSet  executeQuery(String sql)</code></p><p> 执行查询sql</p></li></ol><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>查询的结果</p><ol><li><p><code>boolean next()</code> 游标向下移动一行,返回是否还有数据</p></li><li><p>getXXX() </p><p> XXX : Int、String等</p><p> 参数:</p><pre><code> 1. int 列的编号，从1开始，getInt(1)为获取第一列的int类型的值 2. String  列的名称</code></pre></li></ol><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>预编译sql执行者</p><ol><li><p>sql编写:</p><p> <code>select * from table where name = ?;</code></p></li><li><p>创建PreparedStatement</p><p> <code>Connection.preparedStatement(sql)</code></p></li><li><p>给占位符设置值</p><p> <code>setXXX(参数1:编号从1开始，参数2：要设置的值)</code></p></li><li><p>执行sql</p><p> <code>executeUpdate()/executeQuery()</code></p></li></ol><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>存放数据库连接的容器</p><p><em>当系统被创建，容器被创建，容器中会申请 一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。</em></p><p>好处 ：</p><ol><li>节约资源</li><li>用户访问高效</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>使用javax.sql下的DataSource接口</p><ul><li><p>方法</p><ul><li><p>获取连接：<code>getConnection()</code></p></li><li><p>归还连接：<code>Connection.close()</code> 。</p><p>  此处调用的close不会关闭连接，而是归还连接。</p></li></ul></li></ul><h5 id="C3P0实现"><a href="#C3P0实现" class="headerlink" title="C3P0实现"></a>C3P0实现</h5><ol><li><p>导入jar包 2个</p><p> c3p0-0.9.5.2.jar、mchange-commons-java-0.2.11.jar</p></li><li><p>定义配置文件</p><p> 名称：c3p0-config.xml 、c3p0.properties</p><p> 放到src文件夹下即可</p></li><li><p>创建数据库连接对象 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;congifName&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取连接</p><p> <code>Connection connection = dataSource.getConnection();</code></p></li></ol><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><ol><li><p>导入jar包 </p><p> druid-1.0.9</p></li><li><p>定义配置文件</p><p> properties格式，可起任意名放到任意目录</p></li><li><p>加载配置文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream resourceAsStream = Druid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">properties.load(resourceAsStream);</span><br></pre></td></tr></table></figure></li><li><p>创建数据库连接对象 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接池对象</span></span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">dataSource.getConnection();</span><br></pre></td></tr></table></figure></li><li><p>获取连接</p><p> <code>Connection connection = dataSource.getConnection();</code></p></li></ol><h3 id="Spring-JDBC-JDBCTemplate"><a href="#Spring-JDBC-JDBCTemplate" class="headerlink" title="Spring JDBC(JDBCTemplate)"></a>Spring JDBC(JDBCTemplate)</h3><p>用于简化JDBC操作,自动归还连接至连接池中</p><ul><li><p>创建JDBCTemplate对象</p><p>  <code>JdbcTemplate jdbcTemplate = new JdbcTemplate();</code></p></li><li><p>增删改</p><p>  <code>int update = jdbcTemplate.update(sql,value1...);</code></p></li><li><p>查询并将结果封装为Map</p><p>  <strong>只能查询结果为1的数据</strong></p><p>  <code>Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(sql);</code></p></li><li><p>查询并将结果封装为List</p><p>  <code>List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(sql);</code></p></li><li><p>查询并将结果封装为JavaBean</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;JavaBean&gt; query = jdbcTemplate.query(sql, <span class="keyword">new</span> RowMapper&lt;JavaBean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JavaBean <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//组装对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用提供的实现类实现自动封装</span></span><br><span class="line">List&lt;JavaBean&gt; query = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;JavaBean&gt;(JavaBean.class));</span><br></pre></td></tr></table></figure></li><li><p>指定查询结果的数据类型</p><p>  <em>一般用于聚合函数</em></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long aLong = jdbcTemplate.queryForObject(sql, Long.class);</span><br></pre></td></tr></table></figure></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>包含一些基本的对象，基础的语法，是所有客户端脚本语言的标准</p><h4 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h4><ol><li><p>语句以;结尾如果一行只有一条语句可以不写;</p></li><li><p>变量的定义使用var，也可以不使用</p><ul><li>用var：变量为局部变量</li><li>不用var：变量为全局变量</li></ul></li></ol><h4 id="与html的结合方式"><a href="#与html的结合方式" class="headerlink" title="与html的结合方式"></a>与html的结合方式</h4><ul><li><p>内部JS</p><p>  可以写到html的任意位置，但越靠上越先执行</p></li><li><p>外部JS</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;路径&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>  js文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不需要&lt;script&gt;标签</span><br><span class="line">js代码</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ol><li><p>原始数据类型</p><ol><li><code>number</code> 数字。 整数、小数、NaN(不是数字,与任何值进行<code>==</code>运算皆为<code>false</code>，包括自己)</li><li><code>string</code> 字符串(没有字符的概念) “abv”,’ac’,’a’</li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code>：未定义。如果一个变量没有初始化值，则会被默认赋值为<code>undefined</code></li></ol><p> <em>null使用typeof运算符会得出为object类型</em></p></li><li><p>引用数据类型：对象</p></li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="其他类型转number"><a href="#其他类型转number" class="headerlink" title="其他类型转number"></a>其他类型转number</h5><ul><li><p>string转number类型</p><p>  如果字面值为数字则按字面值进行转换，如果不是为字母，则转为NaN</p></li><li><p>boolean转number类型</p><p>  true为1 false为0</p></li></ul><h5 id="其他类型转boolean"><a href="#其他类型转boolean" class="headerlink" title="其他类型转boolean"></a>其他类型转boolean</h5><ul><li><p>string转boolean类型</p><p>  除了空字符串(“”)，其他都为true</p></li><li><p>number转boolean</p><p>  0或NaN为false，其他为true</p></li><li><p>null和undefined</p><p>  都为false</p></li><li><p>对象</p><p>  都为true</p></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>一元运算符(+ -)</p><p>  如果在运算数前加正负号，会自动将运算数转为数字类型。</p></li><li><p>等于与全等于</p><ul><li><p>&#x3D;&#x3D;等于</p><p>  类型不同时先进行转换，再比较</p></li><li><p>&#x3D;&#x3D;&#x3D; 全等于</p><p>  不会转换类型，类型不相同就为false</p></li></ul></li></ul><h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><h5 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h5><p>函数对象</p><ol><li><p>创建</p><p> 1. </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fun &#x3D; new Function(&quot;a&quot;,&quot;b&quot;,&quot;alert(a+b);&quot;);</span><br></pre></td></tr></table></figure><p> 2. </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fun(a,b) &#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3. </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun &#x3D; function(a,b) &#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性</p><ul><li>length 参数的个数</li></ul></li><li><p>特点</p><ol><li>有返回值的时候直接return就可以</li><li>可以在方法中传入与规定的参数不同数量的 参数（可多可少 ），少了的参数为undefined</li><li>隐藏对象：为一个数组arguments,存放了所有的传入的参数。</li></ol></li></ol><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><p>数组</p><ol><li><p>创建</p><ol><li><code>var arr = new Array(元素列表);</code> </li><li><code>var arr = new Array(默认长度);</code> </li><li><code>var arr = [元素列表];</code></li></ol></li><li><p>方法</p><ul><li><code>join(分割符)</code>:将数组中的元素按照指定的分隔符拼接为字符串。如不传如分割符则默认为<code>,</code></li><li><code>push(元素)</code>: ；在末尾添加元素。类似于<code>java</code>中<code>List.add()</code>;</li></ul></li><li><p>特点</p><ol><li>JS中元素的类型是可变的，可以存放任意类型的数据</li><li>长度可变，当访问超出大小的下标的数据时，自动扩容。</li></ol></li></ol><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>布尔类型的包装类</p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>日期对象</p><ol><li><p>创建</p><p> <code>var date = new date();</code></p></li><li><p>方法</p><ul><li><p><code>toLocalString()</code>:</p><p>  返回当前date对象对应的时间本地字符串格式</p></li><li><p><code>getTime()</code>: </p><p>  获取毫秒值，返回现在时间到1970年1月1日的毫秒值差</p></li></ul></li></ol><h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><p>1.特点<br>    <strong>不需要创建</strong></p><ol start="2"><li><p>方法 </p><ul><li><p><code>Math.random()</code>：</p><p>  返回[0,1)的随机数。</p></li><li><p><code>Math.round(x)</code>：</p><p>  把数四舍五入为最接近的整数。</p></li></ul></li></ol><h5 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h5><p>正则表达式对象</p><ol><li><p>创建</p><ol><li><code>var reg = new RegExp(&quot;正则表达式&quot;);</code></li><li><code>var reg = /正则表达式/;</code></li></ol></li><li><p>方法</p><ul><li><p><code>boolean flag = reg.text(&quot;str&quot;)</code>:</p><p>  测试当前字符串是否符合正则表达式</p></li></ul></li></ol><h5 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h5><ol><li><p>特点<br> 全局对象，这个global对象封装的方法不需要对象就可以直接调用。</p></li><li><p>方法</p><ul><li><p><code>encodeURI()</code>、<code>dncodeURI()</code>:</p><p>  url编解码</p></li><li><p><code>encodeURIComponent()</code>、<code>dncodeURIComponent()</code>:</p><p>  url编解码,编码的字符更多，会将<code>encodeURI</code>不会编码的<code>/</code>等字符进行编码。</p></li><li><p><code>parseInt()</code></p><p>  将字符串逐一判断是否为数字，将第一个字符前的数字转为<code>number</code></p></li><li><p><code>isNaN()</code></p><p>  判断是否等于NaN</p></li><li><p><code>evel(str)</code></p><p>  将一个字符串作为js代码进行执行</p></li></ul></li></ol><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>Browser Object  Model  浏览器对象模型</p><h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>窗口对象,可以获取其他BOM对象</p><ol><li><p>特点</p><ol><li>不需要创建，可以直接使用<code>window.方法名()</code>进行调用.</li><li>window也可以省略。<code>方法名()</code></li></ol></li><li><p>方法</p><ul><li><p>与弹出框有关的方法</p><ol><li><p><code>alert(&quot;str&quot;)</code> 显示一个带有一段消息和一个确认按钮的警告框</p></li><li><p><code>confim(&quot;str&quot;)</code> 显示一个带有一段消息以及确认按钮和取消按钮的对话框。<strong>返回为<code>true</code>为点击确定，返回<code>false</code>为点击取消</strong></p></li><li><p><code>prompt(&quot;str&quot;)</code>: 显示可提示用户输入的对话框,<strong>返回值为用户输入的信息。</strong></p></li></ol></li><li><p>与打开关闭有关的方法</p><ol><li><code>open(&quot;url&quot;)</code>、<code>window.close()</code> 打开一个新窗口、关闭该<code>window</code>对象的窗口。**<code>open</code>会返回一个<code>window</code>对象，可通过该对象对新窗口进行操作，例如关闭窗口.**</li></ol></li><li><p>与定时器有关的方法</p><ol><li><code>setTimeout(fun(),timeout)</code>、<code>clearTimeout()</code> 一次性的定时器 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat timeout &#x3D; 3000;</span><br><span class="line">var id &#x3D; setTimeout(fun(),timeout);</span><br><span class="line">&#x2F;&#x2F;通过id取消定时器</span><br><span class="line">clearTimeout(id);</span><br></pre></td></tr></table></figure></li><li><code>setInterval(fun(),timeout)</code>、<code>clearInterval()</code> 周期性的定时器 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat timeout &#x3D; 3000;</span><br><span class="line">var id &#x3D; setInterval(fun(),timeout);</span><br><span class="line">&#x2F;&#x2F;通过id取消定时器</span><br><span class="line">clearInterval(id);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>属性</p><ol><li>获取其他BOM对象<ul><li>history</li><li>navigator</li><li>location</li><li>screen</li></ul></li><li>获取DOM对象<ul><li>document</li></ul></li></ol></li></ol><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>历史记录对象:包含了用户在当前窗口中访问过的url</p><ol><li><p>获取</p><p> <code>window.history</code></p></li><li><p>方法</p><ul><li><code>back()</code> : 访问历史列表中前一个 url</li><li><code>forward()</code> : 访问历史列表中下一个 url</li><li><code>go()</code> : 访问历史列表某个具体的 url</li></ul></li><li><p>属性 </p><ul><li><code>lenght</code> : 当前窗口历史列表中url数量</li></ul></li></ol><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>地址栏对象</p><ol><li><p>获取</p><p> <code>window.location</code></p></li><li><p>方法</p><p> <code>reload()</code> : 刷新</p></li><li><p>属性 </p><ul><li><code>href</code> : 当前完整的url路径</li></ul></li></ol><h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p>浏览器对象</p><p><strong>可以获取浏览器的名称、版本等信息</strong></p><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p>显示屏对象</p><p><strong>可以获取显示屏的宽高等信息</strong></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>Document Object Model 文档对象模型</p><p><em>将标记语言文档的各个组成部分，封装成对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作。</em></p><h4 id="核心DOM模型对象"><a href="#核心DOM模型对象" class="headerlink" title="核心DOM模型对象"></a>核心DOM模型对象</h4><p>针对任何结构化文档的标准模型</p><ul><li>Document ：文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li><li>Node：节点对象，其他5个的父对象</li></ul><h5 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h5><ol><li><p>方法</p><ol><li>获取Element对象：<ul><li><code>getElementById()</code> : 通过id获取</li><li><code>getElementByTagName()</code> : 通过元素名称获取元素对象们，返回值是一个数组</li><li><code>getElementByClassName()</code> : 通过<code>class</code>属性 获取元素对象们，返回值是一个数组</li><li><code>getElementByClassName()</code> : 通过<code>name</code>属性获取元素对象们，返回值是一个数组</li></ul></li><li>创建其他DOM对象<ul><li><code>createAttribute(name)</code></li><li><code>createComment(name)</code></li><li><code>createElement(name)</code></li><li><code>createTextNode(name)</code></li></ul></li></ol></li><li><p>属性</p></li></ol><h5 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h5><ol><li><p>创建</p><p> 通过<code>document</code>对象进行获取</p></li><li><p>方法</p><ol><li><code>removeAttribute()</code>: 删除属性</li><li><code>setAttribute()</code>: 设置属性</li></ol></li></ol><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>所有的DOM对象都可以认为是一个Node</p><ol><li><p>方法</p><ul><li><code>appendChild()</code> : 向节点的子节点列表的 结尾添加新的子节点。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">&#x2F;&#x2F;添加</span><br><span class="line">parent.appendChild(div);</span><br></pre></td></tr></table></figure></li><li><code>removeChild()</code> : 删除并返回当前节点的指定节点。</li><li><code>replaceChild()</code> : 用新节点替换一个子节点。</li></ul></li><li><p>属性</p><ul><li><code>parentNode</code>: 当前节点的父节点</li></ul></li></ol><h4 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h4><p>是关于如何获取、修改、添加或删除HTML元素的标准</p><h5 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h5><p><strong>innerHTML为该Element内的内容</strong></p><ol><li><p>创建</p><p> <code>div.innerHTML</code></p></li></ol><h5 id="控制样式"><a href="#控制样式" class="headerlink" title="控制样式"></a>控制样式</h5><ul><li><code>element.style.样式名 = XXX;</code></li><li><code>element.classname = &quot;类选择器样式名&quot;;</code></li></ul><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;input&quot;).onblur &#x3D; function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><ol><li><p>点击事件：</p><ol><li><code>onclick</code>：单击事件</li><li><code>ondblclick</code>：双击事件</li></ol></li><li><p>焦点事件</p><ol><li><code>onblur</code>：失去焦点</li><li><code>onfocus</code>:元素获得焦点。</li></ol></li><li><p>加载事件：</p><ol><li><code>onload</code>：一张页面或一幅图像完成加载。</li></ol></li><li><p>鼠标事件：</p><ol><li><code>onmousedown</code>鼠标按钮被按下。</li><li><code>onmouseup</code>鼠标按键被松开。</li><li><code>onmousemove</code>鼠标被移动。</li><li><code>onmouseover</code>鼠标移到某元素之上。</li><li><code>onmouseout</code>鼠标从某元素移开。</li></ol></li><li><p>键盘事件：</p><ol><li><code>onkeydown</code>某个键盘按键被按下。</li><li><code>onkeyup</code>某个键盘按键被松开。</li><li><code>onkeypress</code>某个键盘按键被按下并松开。</li></ol></li><li><p>选择和改变</p><ol><li><code>onchange</code>域的内容被改变。</li><li><code>onselect</code>文本被选中。</li></ol></li><li><p>表单事件：</p><ol><li><code>onsubmit</code>确认按钮被点击。</li><li><code>onreset</code>重置按钮被点击。</li></ol></li></ol><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo1</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Servlet创建时调用，只会执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Servlet访问一次执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器正常关闭时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或直接使用Servlet实现类HttpServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    配置Servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">ServletDemo1</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!--    配置映射 --&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">demo1</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上代码即可实现一个极简的demo</p><h4 id="servlet的创建时机"><a href="#servlet的创建时机" class="headerlink" title="servlet的创建时机"></a>servlet的创建时机</h4><p>默认第一次访问时创建<br>可通过配置文件更改为启动时创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">ServletDemo1</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，当<code>load-on-startup</code>为负数时，则为访问时创建。</p><p>为0或正数时为启动时创建</p><h4 id="servlet3-0注解配置"><a href="#servlet3-0注解配置" class="headerlink" title="servlet3.0注解配置"></a>servlet3.0注解配置</h4><p>不在需要在web.xml中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;)</span></span><br><span class="line"><span class="comment">//或简写成</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="urlpartten"><a href="#urlpartten" class="headerlink" title="urlpartten"></a>urlpartten</h4><p>可以配置多个都可以访问到该servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;,&quot;/demo2&quot;,&quot;/demo3&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><h4 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h4><p><code>GET /day14/demo1?name=zhangsan HTTP/1.1</code></p><ol><li><p>获取请求方式 ：GET</p><p> <code>String getMethod() </code></p></li><li><p>获取虚拟目录：&#x2F;day14</p><p> <code>String getContextPath()</code></p></li><li><p>获取Servlet路径: &#x2F;demo1</p><p> <code>String getServletPath()</code></p></li><li><p>获取get方式请求参数：name&#x3D;zhangsan</p><p> <code>String getQueryString()</code></p><p> <strong>一般不会使用这个获取参数</strong></p></li><li><p>获取请求URI：</p><p> <code>String getRequestURI()</code>:&#x2F;day14&#x2F;demo1</p><p> <code>StringBuffer getRequestURL()</code>  :<a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a></p><p> URL:统一资源定位符 </p><p> URI：统一资源标识符</p></li><li><p>获取协议及版本：HTTP&#x2F;1.1</p><p> <code>String getProtocol()</code></p></li><li><p>获取客户机的IP地址：</p><p> <code>String getRemoteAddr()</code></p></li></ol><h4 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h4><ul><li><code>String getHeader(String name)</code>:通过请求头的名称获取请求头的值</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>:获取所有的请求头名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有请求头信息</span></span><br><span class="line">Enumeration&lt;String&gt; headerNames = req.getHeaderNames();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">    <span class="comment">//获取值</span></span><br><span class="line">    String key = headerNames.nextElement();</span><br><span class="line">    String value = req.getHeader(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据:"></a>获取请求体数据:</h4><p><strong>只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</strong></p><ol><li><p>获取流对象</p><ul><li><p><code>BufferedReader getReader()</code>：获取字符输入流，只能操作字符数据</p></li><li><p><code>ServletInputStream getInputStream()</code>：获取字节输入流，可以操作所有类型数据</p></li></ul></li><li><p>再从流对象中拿数据</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = req.getReader();</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取请求参数通用方式"><a href="#获取请求参数通用方式" class="headerlink" title="获取请求参数通用方式"></a>获取请求参数通用方式</h4><p>get还是post请求方式都可以使用来获取请求参数</p><ol><li><p>根据key获取value</p><p> <code>String getParameter(String name)</code></p></li><li><p>根据1个key获取多个值的数组</p><p> <code>String[] getParameterValues(String name)</code></p></li><li><p>获取所有请求的key</p><p> <code>Enumeration&lt;String&gt; getParameterNames()</code></p></li><li><p>获取所有参数的map集合</p><p> <code>Map&lt;String,String[]&gt; getParameterMap()</code></p></li></ol><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;url&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure><h5 id="转发时传递数据"><a href="#转发时传递数据" class="headerlink" title="转发时传递数据"></a>转发时传递数据</h5><ul><li><p>存放数据至Request中</p><p>  <code>request.setAttribute(&quot;key&quot;,&quot;value:Object&quot;);</code></p></li><li><p>获取数据</p><p>  <code>Object object = request.getAttribute(&quot;key&quot;);</code></p></li><li><p>移除键值对</p><p>  <code>request.removeAttribute(&quot;key&quot;);</code></p></li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><ul><li><p>设置响应状态码</p><p>  <code>setStatus(int code);</code></p></li><li><p>设置响应头</p><p>  <code>setHeader(&quot;key&quot;,&quot;value&quot;);</code></p></li></ul><h4 id="设置返回数据"><a href="#设置返回数据" class="headerlink" title="设置返回数据"></a>设置返回数据</h4><h5 id="返回字符数据"><a href="#返回字符数据" class="headerlink" title="返回字符数据"></a>返回字符数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取流之前 ，设置流的编码</span></span><br><span class="line">response.setCharactereEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//告诉浏览器使用什么编码解码</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;chaset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//或者直接使用</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;chaset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//获取字符输出流</span></span><br><span class="line">PrintWriter pw = response.getWriter();</span><br><span class="line"><span class="comment">//输出字符</span></span><br><span class="line">pw.write(<span class="string">&quot;str&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="返回字节数据"><a href="#返回字节数据" class="headerlink" title="返回字节数据"></a>返回字节数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream sos=response.getOutputStream();</span><br><span class="line">sos.write(<span class="string">&quot;str&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><h4 id="设置弹出下载文件提示框"><a href="#设置弹出下载文件提示框" class="headerlink" title="设置弹出下载文件提示框"></a>设置弹出下载文件提示框</h4><p>设置响应头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;xxx&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><ul><li>使用<code>sendRedirect</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(&quot;url&quot;);</span><br></pre></td></tr></table></figure></li><li>设置响应码与响应头完成重定向  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(302);</span><br><span class="line"></span><br><span class="line">response.setHeader(&quot;location&quot;,&quot;url&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="重定向与转发的特点与区别"><a href="#重定向与转发的特点与区别" class="headerlink" title="重定向与转发的特点与区别"></a>重定向与转发的特点与区别</h3><h4 id="转发-1"><a href="#转发-1" class="headerlink" title="转发"></a>转发</h4><ol><li>地址栏路径不变</li><li>只能转发当前服务器的地址</li><li>转发时一次请求</li><li>可以使用<code>request</code>共享数据</li></ol><h4 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h4><ol><li>地址栏发生改变</li><li>可以跳转任意网址</li><li>是俩次请求</li><li>不可以共享数据</li></ol><h3 id="使用地址时的注意事项"><a href="#使用地址时的注意事项" class="headerlink" title="使用地址时的注意事项"></a>使用地址时的注意事项</h3><ol><li><p>地址是给服务器自身用的</p><p> 可以不加虚拟目录</p></li><li><p>地址是给浏览器用的</p><p> 需要加虚拟目录</p><p> <em><code>request.getContextPath()</code>获取虚拟目录</em></p></li></ol><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>代表整个web应用，可以和服务器通信</p><h5 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取<code>ServletContext</code></h5><ol><li><p>通过<code>request</code>获取:</p><p> <code>request.getServletContext();</code></p></li><li><p>通过<code>HttpServlet</code>获取:</p><p> <code>this.getServletContext();</code></p></li></ol><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>获取MIME类型:</p><p> <code>String mimeType = getMimeType(&quot;filename&quot;)</code></p><p> <em>本质上是根据文件的后缀从而在对应关系表中查询</em></p></li><li><p>共享数据</p><ul><li><p>存放数据</p><p>  <code>setAttribute(&quot;key&quot;,&quot;value:Object&quot;);</code></p></li><li><p>获取数据</p><p>  <code>getAttribute(&quot;key&quot;);</code></p></li><li><p>移除键值对</p><p>  <code>removeAttribute(&quot;key&quot;);</code></p></li></ul><p> <strong>作用范围：整个服务器中所有的请求，所有的用户</strong> </p></li><li><p>获取文件的真实路径</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.getRealPath(<span class="string">&quot;/filename.xxx&quot;</span>); <span class="comment">// 项目目录下的文件</span></span><br><span class="line">context.getRealPath(<span class="string">&quot;/WEB-INF/filename.xxx&quot;</span>); <span class="comment">// WEB-INF目录下的文件</span></span><br><span class="line">context.getRealPath(<span class="string">&quot;/WEB-INF/classes/filename.xxx&quot;</span>); <span class="comment">// src目录下的文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>客户端会话技术(数据保存在本地)</p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li><p>添加<code>cookie</code>信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p> <em>服务器添加了 cookie后，会在响应头中添加<code>set-cookie:cookieKey=cookieValue</code>。</em></p></li><li><p>获取<code>cookie</code></p><p> <em>当浏览器在一次请求中的响应数据中读到了<code>set-cookie</code>，那么当下次请求的时候会通过添加请求头<code>cookie:key=value</code></em></p><p> 服务器中获取</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies &#x3D; request.getCookies();</span><br></pre></td></tr></table></figure></li></ol><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p>默认存在内存中，为当浏览器被关闭则失效，可通过<code>cookie.setMaxAge()</code>更改。</p><ul><li><p>参数为正数</p><p>  将cookie持久化到磁盘，并存活响应的秒数。</p></li><li><p>参数为0</p><p>  删除cookie</p></li><li><p>参数为负数</p><p>  更改为默认模式，当浏览器关闭则失效</p></li></ul><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p>默认为只有当前虚拟目录下的可以获取。可通过<code>cookie.setPath(&quot;path&quot;)</code>来设置需要<code>cookie</code>的作用目录</p><p>不同的服务器项目可通过<code>setDomain</code>来设置</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>存放到浏览器</li><li>单个大小一般不能超过4k</li><li>同一个域名数量一般不能超过20个</li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>服务器会话技术，在一次会话的多次请求中共享数据，数据保存到服务器的HttpSession对象中</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ol><li><p>获取<code>HttpSession</code>：</p><p> <code>HttpSession session = request.getSession();</code></p></li><li><p>使用<code>HttpSession</code>对象：</p><ul><li><p>存放数据</p><p>  <code>setAttribute(&quot;key&quot;,&quot;value:Object&quot;);</code></p></li><li><p>获取数据</p><p>  <code>getAttribute(&quot;key&quot;);</code></p></li><li><p>移除键值对</p><p>  <code>removeAttribute(&quot;key&quot;);</code></p></li></ul></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>session是依赖于cookie的</p><p><strong>获取<code>Session</code>时，会判断<code>cookie</code>中是否含有<code>JSESSIONID</code>,如果没有，则说明为第一次访问，会创建一个<code>Session</code>，并将其id塞入响应头的<code>set-cookie</code>中。当<code>cookie</code>中含有一个<code>JSESSIONID</code>时，根据该id进行获取<code>Session</code>对象</strong></p><h4 id="钝化和活化"><a href="#钝化和活化" class="headerlink" title="钝化和活化"></a>钝化和活化</h4><p>当服务器需要重新启动时，为了保证Session不丢失，需要将Session序列化到本地也就是钝化。重新读取至内存为活化</p><p><em>Tomcat会自动进行钝化和活化。</em></p><h4 id="销毁时机"><a href="#销毁时机" class="headerlink" title="销毁时机"></a>销毁时机</h4><ol><li><p>服务器被关闭</p></li><li><p>自身调用<code>invalidate()</code></p></li><li><p>超出设置的时长，默认为30分钟。可通过在<code>web.xml</code>中更改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;</span><br><span class="line">&lt;&#x2F;session-config&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>存在服务器</li><li>可以存任意类型、任意大小的数据</li></ol><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>既可以写htnl标签，又可以写java代码，<strong>本质上是一个Servlet</strong></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><p><code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ol><li><p><code>page</code>： 配置JSP页面的</p><ul><li><code>contentType</code>：等同于<code>response.setContentType()</code></li><li><code>import</code>：导包</li><li><code>errorPage</code>：当前页面发生异常后，会自动跳转到指定的错误页面</li><li><code>isErrorPage</code>：标识当前是否是错误页面,表示后可以使用内置对象<code>exception</code>。</li></ul></li><li><p><code>include</code>：导入其他页面</p><ul><li><code>&lt;%@include file=&quot;top.jsp&quot;%&gt;</code></li></ul></li><li><p><code>taglib</code>： 导入jstl等资源</p><ul><li><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code><ul><li><code>prefix</code>：前缀，自定义的</li></ul></li></ul></li></ol><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>3中定义脚本的方式</p><ol><li><p><code>&lt;% 代码 %&gt;</code></p><p> 会转换为<code>service</code>中的语句</p></li><li><p><code>&lt;%! 代码 %&gt;</code></p><p> 会转换为类的成员变量位置的代码</p></li><li><p><code>&lt;%= 语句 %&gt;</code></p><p> 输出语句,会输入到页面上</p></li></ol><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>在jsp中不需要获取和创建，可直接使用的对象</p><h5 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h5><ul><li><p><code>PageContext pageContext</code></p><p>  当前页面共享数据,并可以获取其他内置对象</p></li><li><p><code>HttpServletRequest request</code></p></li><li><p><code>HttpSession session</code></p></li><li><p><code>ServletContext application</code></p></li></ul><h5 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h5><ul><li><p><code>HttpServletResponse response</code></p></li><li><p><code>JspWriter out</code></p><p>  字符输出流对象，可以将数据输出到页面上，和<code>response.getWriter()</code>类似,不过输出内容会受位置的影响。</p></li><li><p><code>(Servlet)Object page</code> </p></li><li><p><code>ServletConfig config</code></p></li><li><p><code>Throwable  exception</code></p></li></ul><h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h4><p>用于替换和简化jsp页面中java代码的编写</p><p>语法：<code>$&#123;表达式&#125;</code></p><h5 id="运算："><a href="#运算：" class="headerlink" title="运算："></a>运算：</h5><ol><li>算数运算符： <code>+ - * /(div) %(mod)</code></li><li>比较运算符： <code>&gt; &lt; &gt;= &lt;= == !=</code></li><li>逻辑运算符： <code>&amp;&amp;(and) ||(or) !(not)</code></li><li>空运算符： <code>empty</code>、<code>not empty</code></li></ol><h5 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h5><ol><li><p><code>$&#123;域名称.键名&#125;</code>：从指定域中获取指定键的值</p><ul><li>域名称：<ol><li><code>pageScope</code>—对应的域对象—-&gt; <code>pageContext</code></li><li><code>requestScope</code>—对应的域对象—-&gt;<code>request</code></li><li><code>sessionScope</code>—对应的域对象—-&gt;<code>session</code></li><li><code>applicationScope</code>—对应的域对象—-&gt;<code>application</code></li></ol></li><li>举例：在<code>request</code>域中存储了name&#x3D;张三</li><li>获取：<code>$&#123;requestScope.name&#125;</code></li></ul></li><li><p><code>$&#123;键名&#125;</code>：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取对象、<code>List</code>集合、<code>Map</code>集合的值</p><ol><li><p>对象：<code>$&#123;域名称.键名.属性名&#125;</code></p><ul><li>本质上会去调用对象的getter方法</li></ul></li><li><p><code>List</code>集合：<code>$&#123;域名称.键名[索引]&#125;</code></p></li><li><p><code>Map</code>集合：</p><ul><li><code>$&#123;域名称.键名.key名称&#125;</code></li><li><code>$&#123;域名称.键名[&quot;key名称&quot;]&#125;</code></li></ul></li></ol></li></ol><h5 id="隐式对象："><a href="#隐式对象：" class="headerlink" title="隐式对象："></a>隐式对象：</h5><p>el表达式中有11个隐式对象</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>jsp默认支持el表达式的。如果要忽略el表达式</p><pre><code>1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式2. \$&#123;表达式&#125; ：忽略当前这个el表达式</code></pre><h4 id="jstl表达式"><a href="#jstl表达式" class="headerlink" title="jstl表达式"></a>jstl表达式</h4><p>JavaServer Pages Tag Library  JSP标准标签库</p><p>用于简化和替换jsp页面上的java代码</p><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ol><li>导入jstl相关jar包</li><li>引入标签库：taglib指令：  &lt;%@ taglib %&gt;</li><li>使用标签</li></ol><h5 id="常用的JSTL标签"><a href="#常用的JSTL标签" class="headerlink" title="常用的JSTL标签"></a>常用的JSTL标签</h5><ol><li><p>if:相当于java代码的if语句</p><ol><li>属性：<ul><li>test 必须属性，接受boolean表达式<ul><li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</li><li>一般情况下，test属性值会结合el表达式一起使用</li></ul></li></ul><ol start="2"><li>注意：<ul><li>c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签</li></ul></li></ol></li></ol></li><li><p>choose:相当于java代码的switch语句</p><ol><li>使用choose标签声明         相当于switch声明</li><li>使用when标签做判断         相当于case</li><li>使用otherwise标签做其他情况的声明    相当于default</li></ol></li><li><p>foreach:相当于java代码的for语句</p></li></ol><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>会在配置中的Servlet之前执行,并在Servlet执行完成后执行<code>doFilter</code>后的代码</p><ol><li>实现Filter接口</li><li>配置拦截路径<ul><li><p>注解配置</p><p>  <code>@WebFilter(&quot;url&quot;)</code></p><p>  <code> @WebFilter(value = &quot;/*&quot;,dispatcherTypes = DispatcherType.REQUEST)</code></p></li><li><p><code>web.xml</code>配置</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">FilterDemo</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;<span class="title">url</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">   &lt;!-- 拦截方式配置 --&gt;</span></span><br><span class="line"><span class="class">   &lt;<span class="title">dispatcher</span>&gt;<span class="title">REQUEST</span>&lt;/<span class="title">dispatcher</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="放行"><a href="#放行" class="headerlink" title="放行"></a>放行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5种拦截方式-dispatcherTypes"><a href="#5种拦截方式-dispatcherTypes" class="headerlink" title="5种拦截方式 dispatcherTypes"></a>5种拦截方式 dispatcherTypes</h4><ol><li>REQUEST：默认值。浏览器直接请求资源</li><li>FORWARD：转发访问资源</li><li>INCLUDE：包含访问资源</li><li>ERROR：错误跳转资源</li><li>ASYNC：异步访问资源</li></ol><h4 id="多个拦截器执行顺序问题"><a href="#多个拦截器执行顺序问题" class="headerlink" title="多个拦截器执行顺序问题"></a>多个拦截器执行顺序问题</h4><ol><li>按类名的字符以此比较，小的先执行</li><li>xml配置的位置，从上到下执行</li></ol><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>监听ServletContext对象的创建和销毁</p><p>一般用于加载资源文件</p><ol><li><p>实现<code>ServletContextListener</code>接口</p></li><li><p>配置</p><ul><li><p>xml</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line"> &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">     &lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure></li><li><p>注解 <code>@WebListener</code></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android开发艺术探索》笔记</title>
      <link href="/2021/03/26/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/26/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Activty的生命周期和启动模式"><a href="#第一章-Activty的生命周期和启动模式" class="headerlink" title="第一章 Activty的生命周期和启动模式"></a>第一章 Activty的生命周期和启动模式</h1><h2 id="Activity的生命周期全面分析"><a href="#Activity的生命周期全面分析" class="headerlink" title="Activity的生命周期全面分析"></a>Activity的生命周期全面分析</h2><h3 id="典型情况下的生命周期分析"><a href="#典型情况下的生命周期分析" class="headerlink" title="典型情况下的生命周期分析"></a>典型情况下的生命周期分析</h3><p>在正常的情况下，Activity会经历如下生命周期。</p><ol><li><code>onCreate</code>: <strong>表示Activity正在被创建</strong>,是生命周期的第一个方法</li><li><code>onRestart</code>: <strong>表示Activity正在被重新启动</strong>。一般由用户从ActivityA启动ActivityB后，重新返回ActivityA触发。</li><li><code>onStart</code>: <strong>表示Activity已经可见，但无法与用户交互</strong>。<em>（没有获取到焦点）</em></li><li><code>onResume</code>: <strong>表示activity获得了焦点，用户可以进行操作</strong>。</li><li><code>onPause</code>: <strong>Activity正在停止，失去了焦点，不能进行操作</strong>。此时可以做一些存储数据、停止动画等工作，但<strong>不能太耗时，会影响新Activity的显示</strong> <em>（新Activity的onResume会在老Activity的<code>onPause</code>方法后执行）</em></li><li><code>onStop</code>: <strong>表示Activity即将停止，对用户来说已经不可见。</strong> 可以在此时做稍重的回收工作，也不能太耗时。<strong>一般的操作尽量在onStop中执行,不要放到onPause中</strong></li><li><code>onDestory</code> : <strong>表示activity即将被销毁</strong>,是最后一个回调。可以做回收工作和最终资源的释放。</li></ol><span id="more"></span><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/2509931-1409c13efedd9b37.PNG" alt="image"></p><h3 id="异常情况下的生命周期分析"><a href="#异常情况下的生命周期分析" class="headerlink" title="异常情况下的生命周期分析"></a>异常情况下的生命周期分析</h3><ol><li><p>资源相关的系统配置发生改变导致Activity被杀死并重新创建</p><p> 在不对Activity进行配置时，旋转手机等操作会使系统配置发生改变，会引发Activity销毁并重新创建。</p><ul><li><p>销毁</p><p>  当Activity开始销毁时，其onPause、onStop、onDestory均会被调用，并在<strong>onStop之前</strong>调用<code>onSaveInstanceState</code>来保存当前Activity的状态 <em>（与onPause没有明确的调用前后顺序）</em>。</p></li><li><p>保存</p><p>  将需要保存的数据保存到<code>onSaveInstanceState</code>传入的<code>bundle</code>中。<strong>注意</strong>：<code>onSaveInstanceState</code>有俩个同名函数，通常只需重写<code>onSaveInstanceState(Bundle outState)</code>的即可，<code>onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123;</code>只有在activity中配置<code>persistableMode</code>标签才会调用，此标签用于数据的持久化。</p></li><li><p>恢复</p><p>  当Activity重建后，会将保存的bundle数据在<code>onCreate(Bundle b)</code>的参数中传入,并调用<code>onRestoreInstanceState</code>。如果要在onCreate中进行状态恢复需要进行对bundle进行判空，<strong>推荐在<code>onRestoreInstanceState</code>中进行状态的恢复</strong>,因为该方法一旦调用，其参数一定不为空。</p><p>  <code>onRestoreInstanceState</code>的调用时机在<code>onStart</code>之后，与<code>onResume</code>的调用时机不能保证。</p></li><li><p>调用输出顺序</p></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Activity正常创建</span><br><span class="line">I&#x2F;Main2Activity: onCreate: </span><br><span class="line">I&#x2F;Main2Activity: onStart: </span><br><span class="line">I&#x2F;Main2Activity: onResume: </span><br><span class="line">&#x2F;&#x2F;屏幕旋转导致Activity开始销毁</span><br><span class="line">I&#x2F;Main2Activity: onPause: </span><br><span class="line">&#x2F;&#x2F;保存数据</span><br><span class="line">I&#x2F;Main2Activity: onSaveInstanceState:</span><br><span class="line">I&#x2F;Main2Activity: onStop: </span><br><span class="line">I&#x2F;Main2Activity: onDestroy: </span><br><span class="line">&#x2F;&#x2F;开始重建</span><br><span class="line">I&#x2F;Main2Activity: onCreate: </span><br><span class="line">I&#x2F;Main2Activity: onStart: </span><br><span class="line">&#x2F;&#x2F;恢复数据</span><br><span class="line">I&#x2F;Main2Activity: onRestoreInstanceState:</span><br><span class="line">I&#x2F;Main2Activity: onResume: </span><br></pre></td></tr></table></figure><pre><code>系统只有在Activity即将被销毁并有机会重新显示的情况下才会调用`onSaveInstanceState`,正常退出的Activity是不会触发调用</code></pre><ol start="2"><li><p>资源内存不足导致低优先级的Activity被杀死</p><p> Activity优先级排序</p><ol><li>前台Activity – 正在和用户交互的Activity,优先级最高</li><li>可见但非前台Activity – 比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法与用户直接交互。</li><li>后台Activity – 已经被暂停的Activity，比如执行了onStop,优先级最低。</li></ol><p> 当系统系统内存不足时，系统会按照上述优先级去杀死Activity所在的进程，并在后续通过<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>来存储和恢复数据。</p></li></ol><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><ol><li><p>standard:</p><p> 标准模式，也是默认模式。<strong>每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。</strong>，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中。</p><p> <em>当用ApplicationContext去启动standard模式的Activity会报错，因为非Activity类型的Context没有任务栈，此时，需要为Activity指定<code>FLAG_ACTIVITY_NEW_TASK</code>标记位新建一个任务栈来存放这个Activity。此时，该Activity实际上使用singTask模式启动的</em></p></li><li><p>singleTop:</p><p> 栈顶复用模式。<strong>如果新Acitivy已经位于任务栈的栈顶，那么此Activiy不会被重新创建，但是会被调用该Activity的<code>onNewIntent</code>方法</strong>。</p></li><li><p>singleTask:</p><p> 栈内复用模式，在这种模式下，入栈时，在目标栈中如果存在此Activity实例，那么不会重新创建实例。<strong>当已经存在的实例不在栈顶时，会先将栈中实例之上的Activity全部出栈，移出任务栈，使singleTask模式的Activity位于栈顶</strong>。当栈中存在的实例在栈顶时，直接入栈，并调用<code>onNewIntent</code></p></li><li><p>单实例模式。该模式具有singleTask模式的所有特性外，还有这个模式的Acitivity<strong>只能单独的位于一个任务栈中</strong>。启动时，会新建一个任务栈，该任务栈只会有该Acitivity一个实例。</p></li></ol><h3 id="任务栈回退"><a href="#任务栈回退" class="headerlink" title="任务栈回退"></a>任务栈回退</h3><p><em>在存在多个任务栈的情况下，由前台任务栈（第一个有焦点的Activity所在的任务栈）启动后台任务栈中的Activity的时候，整个后台任务栈会被切换为前台任务栈，整个栈中的Activity都会前移，之前的前台任务栈集体后移。</em></p><p><strong>当启动ActivityD时的任务栈</strong></p><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%9B%9E%E9%80%801.png" alt="任务栈回退1"><br><strong>当启动ActivityC时的任务栈</strong></p><p><img src="https://tuchuang-beijing.oss-cn-beijing.aliyuncs.com/%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%9B%9E%E9%80%802.png" alt="任务栈回退2"></p><p>ActivityD被出栈的原因：++当启动ActivityC时，C处于后台任务栈中，首先将整个任务栈提到前台任务栈，变为 D -&gt; C -&gt; B -&gt; A,又因为C的启动模式为SingleTask，当不为栈顶时会将之上的Activity全部出栈。++</p><h3 id="onNewIntent的调用时机"><a href="#onNewIntent的调用时机" class="headerlink" title="onNewIntent的调用时机"></a>onNewIntent的调用时机</h3><h3 id="Activity-的-Flags"><a href="#Activity-的-Flags" class="headerlink" title="Activity 的 Flags"></a>Activity 的 Flags</h3><h1 id="第三章-View的事件体系"><a href="#第三章-View的事件体系" class="headerlink" title="第三章 View的事件体系"></a>第三章 View的事件体系</h1><h2 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h2><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>View的位置信息由4个顶点来决定，分别为top、left、bottom、right，这都是<strong>相对于View的父控件</strong>来说的。所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width &#x3D; right - left</span><br><span class="line">height &#x3D; bottom - top</span><br></pre></td></tr></table></figure><p>从Android3.0开始增加了x,y,translationX,translationY。其中<strong>x，y是View左上角的坐标</strong>，translationX和translationY<strong>是View左上角相对于父容器的偏移量</strong>。换算关系如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; left + translationX</span><br><span class="line">y &#x3D; top + translationY</span><br></pre></td></tr></table></figure><p>View在平移变换中，top，left表示的是原始左上角的位置信息 ，<strong>不会改变</strong>，而<strong>x，y，translationX，translationY会发生改变</strong></p><h3 id="MotionEvent-和-TouchSlop"><a href="#MotionEvent-和-TouchSlop" class="headerlink" title="MotionEvent 和 TouchSlop"></a>MotionEvent 和 TouchSlop</h3><ol><li><p>MotionEvent</p><p> 通过MotionEvent可以获得点击事件的x，y坐标。getX&#x2F;getY获取的是相对于<strong>当前View</strong>左上角的x和y，而getRawX&#x2F;getRawY获取的是相对于<strong>手机屏幕</strong>左上角的坐标</p></li><li><p>TouchSlop</p><p> TouchSlop为滑动的最小距离，当小于这个距离则不认为是滑动，<strong>TouchSlop是一个常量</strong>，和设备有关，在不同的设备上有可能不同，可以通过<code>ViewConfiguration,get(getContext()).getScaledTouchSlop()</code>。当处理滑动时，可以获取这个值进行判断来认为是不是滑动。</p></li></ol><h3 id="VelocityTracker-GestureDetector-和-Scroller"><a href="#VelocityTracker-GestureDetector-和-Scroller" class="headerlink" title="VelocityTracker GestureDetector 和 Scroller"></a>VelocityTracker GestureDetector 和 Scroller</h3><ol><li><p>VelocityTracker</p><p> VelocityTracker用于计算滑动速度。在View的onTouchEvent中进行创建和添加监听</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);</span><br></pre></td></tr></table></figure><p> 初始化完成就可以获取水平方向和垂直方向的滑动速度。<strong>在获取速度之前，必须要先调用computeCurrentVelocity进行计算速度。</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;必须先调用这个</span><br><span class="line">velocityTracker.computeCurrentVelocity(1000); &#x2F;&#x2F;设置时间间隔为1000，计算在这个时间间隔中运动了多少个像素  </span><br><span class="line">Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());  </span><br><span class="line">Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getYVelocity());</span><br></pre></td></tr></table></figure><p> 使用完成后，需要进行释放</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br><span class="line">velocityTracker = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>GestureDetector</p><p> 手势检测工具，用于辅助检测用户的<strong>单击、滑动、长按、双击</strong></p><p> <strong>回调接口：</strong></p><ul><li><p>OnGestureListener，这个Listener监听一些手势，如单击、滑动、长按等操作；</p><table><thead><tr><th align="left"><div style="width:150px">方法名</div></th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">onDown</td><td align="center">手指轻轻触摸屏幕的一瞬间，由1个Action_down触发</td></tr><tr><td align="left">onShowPress</td><td align="center">手指轻轻触摸屏幕，尚未松开或拖动，由1个ACTION_DOWN触发</td></tr><tr><td align="left">onLongPress</td><td align="center">用户长按屏幕</td></tr><tr><td align="left">onSingleTapUp</td><td align="center">用户手指松开（UP事件）的时候如果没有执行onScroll()和onLongPress()这两个回调的话，就会回调这个，说明这是一个点击抬起事件，但是不能区分是否双击事件的抬起。</td></tr><tr><td align="left">onScroll</td><td align="center">手指按下并拖动，由1个ACTION_DOWN+多个ACTION_MOVE触发</td></tr><tr><td align="left">onFling</td><td align="center">用户执行快速滑动之后的回调，MOVE事件之后手松开（UP事件）那一瞬间的x或者y方向速度，如果达到一定数值（源码默认是每秒50px），就是快速滑动操作（也就是快速滑动的时候松手会有这个回调，因此基本上有onFling必然有onScroll）。</td></tr></tbody></table></li><li><p>OnDoubleTapListener，这个Listener监听双击和单击事件。</p>  <div style="width:150px">方法名</div>   | 描述  ---|---  onSingleTapConfirmed | 可以确认（通过单击DOWN后300ms没有下一个DOWN事件确认）这不是一个双击事件，而是一个单击事件的时候会回调。  onDoubleTap | 可以确认这是一个双击事件的时候回调。  onDoubleTapEvent | onDoubleTap()回调之后的输入事件（DOWN、MOVE、UP）都会回调这个方法（这个方法可以实现一些双击后的控制，如让View双击后变得可拖动等）。</li><li><p>OnContextClickListener 平板接入外接键盘后，鼠标&#x2F;触摸板，右键点击时候的回调。</p></li><li><p><strong>SimpleOnGestureListener，实现了上面三个接口的类，拥有上面三个的所有回调方法。一般会使用该接口</strong></p></li></ul><p> 使用方式：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建GestureDetector对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">//按需重写相关回调</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onDown(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接管View的onTouchEvent</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mGestureDetector.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><p>3.Scroller</p><p>使用Scroller对象完成弹性滑动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</span><br><span class="line"><span class="comment">//缓慢移动到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> delta = destX - scrollX;</span><br><span class="line">    <span class="comment">//1000ms内滑向destX,效果就是慢慢滑动</span></span><br><span class="line">    mScroller.startScroll(scrollX,<span class="number">0</span>,delta,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="使用scrollTo-x2F-scrollBy完成View的滑动"><a href="#使用scrollTo-x2F-scrollBy完成View的滑动" class="headerlink" title="使用scrollTo&#x2F;scrollBy完成View的滑动"></a>使用scrollTo&#x2F;scrollBy完成View的滑动</h3><p>Android源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the x position to scroll to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the y position to scroll to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Move the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
